<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode-Hard on Cuckooemm&#39;s Blog</title>
    <link>https://cuckooemm.xyz/tags/leetcode-hard/</link>
    <description>Recent content in LeetCode-Hard on Cuckooemm&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 11 Jul 2019 13:09:57 +0800</lastBuildDate>
    
	<atom:link href="https://cuckooemm.xyz/tags/leetcode-hard/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode - 41 - First Missing Positive [Hard]</title>
      <link>https://cuckooemm.xyz/2019/july/41-first-missing-positive/</link>
      <pubDate>Thu, 11 Jul 2019 13:09:57 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/41-first-missing-positive/</guid>
      <description>41.First Missing Positive 地址
难度：Hard
题目描述 Given an unsorted integer array, find the smallest missing positive integer.
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。
示例 Example 1: Input: [1,2,0]
Output: 3
Example 2: Input: [3,4,-1,1]
Output: 2
Example 3: Input: [7,8,9,11,12]
Output: 1
Note: Your algorithm should run in O(n) time and uses constant extra space.
思路 利用桶排序的思路。
负数与大于数组长度的数字不考虑。
用数组中的数当作索引，存放在nums[i] - 1 的索引位置。
AC  Runtime: 0 ms, faster than 100.00% of C++ online submissions for First Missing Positive.</description>
    </item>
    
    <item>
      <title>Leetcode - 25 - Reverse Nodes in k Group [Hard]</title>
      <link>https://cuckooemm.xyz/2019/june/25-reverse-nodes-in-k-group/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/25-reverse-nodes-in-k-group/</guid>
      <description>25.Reverse Nodes in k Group 地址
难度：Hard
题目描述 Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</description>
    </item>
    
    <item>
      <title>LeetCode - 23 - Merge k Sorted Lists [Hard]</title>
      <link>https://cuckooemm.xyz/2019/june/23-merge-k-sorted-lists/</link>
      <pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/23-merge-k-sorted-lists/</guid>
      <description>23.Merge k Sorted Lists 地址
难度：Hard
题目描述 Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。
实例 Example: Input:
[
1-&amp;gt;4-&amp;gt;5,
1-&amp;gt;3-&amp;gt;4,
2-&amp;gt;6
]
Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6
思路 使用优先队列解决。 时间复杂度:O(n log k), 空间复杂度：O(k)。
AC  Runtime: 20 ms, faster than 99.55% of C++ online submissions for Merge k Sorted Lists. Memory Usage: 11.3 MB, less than 65.67% of C++ online submissions for Merge k Sorted Lists.</description>
    </item>
    
  </channel>
</rss>