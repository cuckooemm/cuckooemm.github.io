<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cuckooemm&#39;s Blog on Cuckooemm&#39;s Blog</title>
    <link>https://cuckooemm.xyz/</link>
    <description>Recent content in Cuckooemm&#39;s Blog on Cuckooemm&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 30 Jul 2019 23:23:00 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>微服务改造 - 1</title>
      <link>https://cuckooemm.xyz/2019/july/microservice-campus-1/</link>
      <pubDate>Tue, 30 Jul 2019 23:23:00 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/microservice-campus-1/</guid>
      <description>

&lt;h1 id=&#34;校园墙微服务改造&#34;&gt;校园墙微服务改造&lt;/h1&gt;

&lt;h3 id=&#34;想法&#34;&gt;想法&lt;/h3&gt;

&lt;p&gt;自从完成之前的校园墙APP的前后端开发后，已经懒得在之前基础上进行增加功能和升级。原因除了自身毕业后没啥动力继续开发，还有便是单体架构的自身缺陷了，因此便有了把这个项目改造成微服务的想法。&lt;/p&gt;

&lt;p&gt;之前项目已从阿里云下线，APP内域名已到期懒得重新编译，(也没人用)所以下线了服务端节省资源。&lt;/p&gt;

&lt;p&gt;本次改造的主要目的是通过这次改造认识后端开发中所可能产生的各种问题和与之对应的优雅的处理方案。&lt;/p&gt;

&lt;h3 id=&#34;目标&#34;&gt;目标&lt;/h3&gt;

&lt;h4 id=&#34;实现一个完整的微服务项目&#34;&gt;实现一个完整的微服务项目&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;构建微服务&lt;/li&gt;
&lt;li&gt;Redis集群&lt;/li&gt;
&lt;li&gt;配置下发&lt;/li&gt;
&lt;li&gt;熔断，限流，负载均衡…&lt;/li&gt;
&lt;li&gt;链路追踪，日志收集与展示&lt;/li&gt;
&lt;li&gt;消息队列&lt;/li&gt;
&lt;li&gt;单元测试&lt;/li&gt;
&lt;li&gt;服务docker化&lt;/li&gt;
&lt;li&gt;用k8s做服务注册与发现&lt;/li&gt;
&lt;li&gt;使用k8s部署，并配置服务的水平扩展&lt;/li&gt;
&lt;li&gt;持续集成&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;框架&#34;&gt;框架&lt;/h3&gt;

&lt;p&gt;经过几个框架的对比，最终选择了&lt;a href=&#34;https://github.com/micro/go-micro&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;go-micro&lt;/a&gt;框架。&lt;/p&gt;

&lt;h3 id=&#34;模块&#34;&gt;模块&lt;/h3&gt;

&lt;p&gt;初步定为以下微服务模块:&lt;/p&gt;

&lt;h4 id=&#34;1-user&#34;&gt;1.User:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;为其他模块提供用户信息与身份认证&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-oss&#34;&gt;2.OSS:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;自建一个阿里云OSS精简版&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-动态&#34;&gt;3.动态:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;校园动态&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-短视频&#34;&gt;4.短视频:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;接触一下音视频的知识&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;5-push&#34;&gt;5.PUSH&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;提供消息推送&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;6-评论&#34;&gt;6.评论&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;为其他模块添加评论的支持&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果上面完成则进行下面的尝试&lt;/p&gt;

&lt;p&gt;1.IM
2.直播&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 50 - Pow(x,n) [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/50-pow/</link>
      <pubDate>Sat, 13 Jul 2019 18:45:55 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/50-pow/</guid>
      <description>

&lt;h1 id=&#34;50-pow-x-n&#34;&gt;50.Pow(x,n)&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/powx-n/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Implement pow(x, n), which calculates x raised to the power n (xn).&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 2.00000, 10&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 1024.00000&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 2.10000, 3&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 9.26100&lt;/p&gt;

&lt;h4 id=&#34;example-3&#34;&gt;Example 3:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 2.00000, -2&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 0.25000&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; 2-2 = &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;22&lt;/sub&gt; = &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; = 0.25&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;快速幂。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 72.85% of C++ online submissions for Pow(x, n).&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.5 MB, less than 21.03% of C++ online submissions for Pow(x, n).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    double myPow(double x, int n) {
        double res = 1.0;
        for (int i = n; i != 0; i /= 2) {
            if (i &amp;amp; 1) res *= x;
            x *= x;
        }
        return n &amp;lt; 0 ? 1 / res : res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 49 - Group Anagrams [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/49-group-anagrams/</link>
      <pubDate>Sat, 13 Jul 2019 16:34:53 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/49-group-anagrams/</guid>
      <description>

&lt;h1 id=&#34;49-group-anagrams&#34;&gt;49.Group Anagrams&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/group-anagrams/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given an array of strings, group anagrams together.&lt;/p&gt;

&lt;p&gt;All inputs will be in lowercase.
The order of your output does not matter.&lt;/p&gt;

&lt;p&gt;给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [&amp;ldquo;eat&amp;rdquo;, &amp;ldquo;tea&amp;rdquo;, &amp;ldquo;tan&amp;rdquo;, &amp;ldquo;ate&amp;rdquo;, &amp;ldquo;nat&amp;rdquo;, &amp;ldquo;bat&amp;rdquo;],&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[
  [&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;],
  [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],
  [&amp;quot;bat&amp;quot;]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;用质数代表各个字母,字符串中所有字符质数相乘得到唯一的积。如果不同字符串乘积相等，则字符串由同样的字符组成。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 36 ms, faster than 92.92% of C++ online submissions for Group Anagrams.&lt;/li&gt;
&lt;li&gt;Memory Usage: 17.5 MB, less than 93.13% of C++ online submissions for Group&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; groupAnagrams(vector&amp;lt;string&amp;gt;&amp;amp; strs) {
        vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res;
        unordered_map&amp;lt;double,int&amp;gt; index;
        double z;
        int prime[] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101 };
        for(int i = 0; i &amp;lt; strs.size(); ++i){
            z = 1;
            for(int j = 0; j &amp;lt; strs[i].size(); ++j){
                z *= prime[strs[i][j] - 97];
            }
            auto it = index.find(z);
            if(it != index.end()){
                res[it-&amp;gt;second].push_back(strs[i]);
            }else{
                vector&amp;lt;string&amp;gt; t{strs[i]};
                res.push_back(t);
                index[z] = res.size() - 1;
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 48 - Rotate Image [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/48-rotate-image/</link>
      <pubDate>Sat, 13 Jul 2019 16:16:44 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/48-rotate-image/</guid>
      <description>

&lt;h1 id=&#34;48-rotate-image&#34;&gt;48.Rotate Image&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/rotate-image/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;You are given an n x n 2D matrix representing an image.&lt;/p&gt;

&lt;p&gt;Rotate the image by 90 degrees (clockwise).&lt;/p&gt;

&lt;p&gt;给定一个 n × n 的二维矩阵表示一个图像。&lt;/p&gt;

&lt;p&gt;将图像顺时针旋转 90 度。&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;双循环，每次循环交换4个元素。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 87.39% of C++ online submissions for Rotate Image.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9 MB, less than 68.89% of C++ online submissions for Rotate Image.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    void rotate(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) {
        int tmp = 0;
        int size = matrix.size();
        for(int i = 0; i &amp;lt; size / 2; ++i)
            for(int j = i; j &amp;lt; size - i - 1; ++j){
                tmp = matrix[i][j];
                matrix[i][j] = matrix[size - j - 1][i];
                matrix[size - j - 1][i] = matrix[size - i - 1][size - j - 1];
                matrix[size - i - 1][size - j - 1] = matrix[j][size - i - 1];
                matrix[j][size - i - 1] = tmp;
            }
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 47 - Permutations II [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/47-permutations-ii/</link>
      <pubDate>Sat, 13 Jul 2019 11:02:19 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/47-permutations-ii/</guid>
      <description>

&lt;h1 id=&#34;47-permutations-ii&#34;&gt;47.Permutations II&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/permutations-ii/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a collection of numbers that might contain duplicates, return all possible unique permutations.&lt;/p&gt;

&lt;p&gt;给定一个可包含重复数字的序列，返回所有不重复的全排列。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,1,2]&lt;br /&gt;
*Output:**&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;对数据排序。&lt;br /&gt;
与上一题相比，递归参数非引用传递。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 20 ms, faster than 96.68% of C++ online submissions for Permutations II.&lt;/li&gt;
&lt;li&gt;Memory Usage: 10.9 MB, less than 28.29% of C++ online submissions for Permutations II.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
private:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    vector&amp;lt;bool&amp;gt; memo;
    void dfs(vector&amp;lt;int&amp;gt; nums,int index){
        if(index == nums.size() - 1){
            res.push_back(nums);
            return ;
        }
        for(int i = index; i &amp;lt; nums.size(); ++i){
            if((i == index)||(nums[i] != nums[index])){  
                swap(nums[i],nums[index]);
                dfs(nums,index + 1);
            }
        }
    }
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permuteUnique(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        sort(nums.begin(),nums.end());
        dfs(nums,0);
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 46 - Permutations [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/46-permutations/</link>
      <pubDate>Fri, 12 Jul 2019 20:39:56 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/46-permutations/</guid>
      <description>

&lt;h1 id=&#34;46-permutations&#34;&gt;46.Permutations&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/permutations/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a collection of distinct integers, return all possible permutations.&lt;/p&gt;

&lt;p&gt;给定一个没有重复数字的序列，返回其所有可能的全排列。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,2,3]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;递归回溯。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 12 ms, faster than 77.50% of C++ online submissions for Permutations.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9.3 MB, less than 52.10% of C++ online submissions for Permutations.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
private:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    void dfs(vector&amp;lt;int&amp;gt;&amp;amp; nums, int index){
        if(index == nums.size() - 1){
            res.push_back(nums);
            return;
        }
        for(int i = index; i &amp;lt; nums.size(); ++i){
            swap(nums[index],nums[i]);
            dfs(nums,index + 1);
            swap(nums[index],nums[i]);
        }
    }
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        dfs(nums,0);
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 45 - Jump Game II [Hard]</title>
      <link>https://cuckooemm.xyz/2019/july/45-jump-game-ii/</link>
      <pubDate>Fri, 12 Jul 2019 15:53:59 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/45-jump-game-ii/</guid>
      <description>

&lt;h1 id=&#34;45-jump-game-ii&#34;&gt;45.Jump Game II&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/jump-game-ii/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Hard&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given an array of non-negative integers, you are initially positioned at the first index of the array.&lt;/p&gt;

&lt;p&gt;Each element in the array represents your maximum jump length at that position.&lt;/p&gt;

&lt;p&gt;Your goal is to reach the last index in the minimum number of jumps.&lt;/p&gt;

&lt;p&gt;给定一个非负整数数组，你最初位于数组的第一个位置。&lt;/p&gt;

&lt;p&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p&gt;

&lt;p&gt;你的目标是使用最少的跳跃次数到达数组的最后一个位置。&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;You can assume that you can always reach the last index.&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [2,3,1,1,4]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 2&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; The minimum number of jumps to reach the last index is 2.Jump 1 step from index 0 to 1, then 3 steps to the last index.&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;贪心算法。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 12 ms, faster than 79.39% of C++ online submissions for Jump Game II.&lt;/li&gt;
&lt;li&gt;Memory Usage: 10.1 MB, less than 59.27% of C++ online submissions for Jump Game II.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int jump(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int end = 0, step = 0, res = 0;
        for(int i = 0; i &amp;lt; nums.size() - 1; ++i){
            step = max(step, nums[i] + i); 
            if(i == end){                          // 达到边界，更新
                end = step;
                ++res;
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 44 - Wildcard Matching [Hard]</title>
      <link>https://cuckooemm.xyz/2019/july/44-wildcard-matching/</link>
      <pubDate>Fri, 12 Jul 2019 13:15:52 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/44-wildcard-matching/</guid>
      <description>

&lt;h1 id=&#34;44-wildcard-matching&#34;&gt;44.Wildcard Matching&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/wildcard-matching/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Hard&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for &amp;lsquo;?&amp;rsquo; and &amp;lsquo;*&amp;lsquo;.&lt;/p&gt;

&lt;p&gt;&amp;rsquo;?&amp;rsquo; Matches any single character.&lt;br /&gt;
&amp;lsquo;*&amp;rsquo; Matches any sequence of characters (including the empty sequence).&lt;/p&gt;

&lt;p&gt;The matching should cover the entire input string (not partial).&lt;/p&gt;

&lt;p&gt;给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 &amp;rsquo;?&amp;lsquo; 和 &amp;rsquo;*&amp;lsquo; 的通配符匹配。&lt;/p&gt;

&lt;p&gt;&amp;rsquo;?&amp;rsquo; 可以匹配任何单个字符。&lt;br /&gt;
&amp;lsquo;*&amp;rsquo; 可以匹配任意字符串（包括空字符串）。&lt;/p&gt;

&lt;p&gt;两个字符串完全匹配才算匹配成功。&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;s could be empty and contains only lowercase letters a-z.&lt;/li&gt;
&lt;li&gt;p could be empty and contains only lowercase letters a-z, and characters like ? or *.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;br /&gt;
s = &amp;ldquo;aa&amp;rdquo;&lt;br /&gt;
p = &amp;ldquo;a&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; false&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; &amp;ldquo;a&amp;rdquo; does not match the entire string &amp;ldquo;aa&amp;rdquo;.&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;br /&gt;
s = &amp;ldquo;aa&amp;rdquo;&lt;br /&gt;
p = &amp;ldquo;*&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; true&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; &amp;lsquo;*&amp;rsquo; matches any sequence.&lt;/p&gt;

&lt;h4 id=&#34;example-3&#34;&gt;Example 3:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;br /&gt;
s = &amp;ldquo;cb&amp;rdquo;&lt;br /&gt;
p = &amp;ldquo;?a&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; false&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; &amp;lsquo;?&amp;rsquo; matches &amp;lsquo;c&amp;rsquo;, but the second letter is &amp;lsquo;a&amp;rsquo;, which does not match &amp;lsquo;b&amp;rsquo;.&lt;/p&gt;

&lt;h4 id=&#34;example-4&#34;&gt;Example 4:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;br /&gt;
s = &amp;ldquo;adceb&amp;rdquo;&lt;br /&gt;
p = &amp;ldquo;*a*b&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; true&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; The first &amp;lsquo;&lt;em&gt;&amp;rsquo; matches the empty sequence, while the second &amp;lsquo;&lt;/em&gt;&amp;rsquo; matches the substring &amp;ldquo;dce&amp;rdquo;.&lt;/p&gt;

&lt;h4 id=&#34;example-5&#34;&gt;Example 5:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;br /&gt;
s = &amp;ldquo;acdcb&amp;rdquo;&lt;br /&gt;
p = &amp;ldquo;a*c?b&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; false&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 99.25% of C++ online submissions for Wildcard Matching.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 94.48% of C++ online submissions for Wildcard Matching.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool isMatch(string s, string p) {
        int sl = s.size(),pl = p.size();
        int i = 0, j = 0;
        int start = -1, match = 0;
        while(i &amp;lt; sl){
            if(j &amp;lt; pl &amp;amp;&amp;amp; (s[i] == p[j] || p[j] == &#39;?&#39;)){   // 匹配相等或p当前为 ? 符
                ++i;
                ++j;
            }else if(j &amp;lt; pl &amp;amp;&amp;amp; p[j] == &#39;*&#39;){               // * 匹配任意 并记录当前 * 开始的位置 与 s 字符串中当前位置
                start = j;
                match = i;
                ++j;
            }else if(start != -1){                         // 已遇到过 * 并把上次记录p的索引位置+1 赋值给 j s索引i从记录位置的下一位开始
                j = start + 1;
                i = ++match;
            }else{                                         // 不匹配返回
                return false;
            }
        }
        while(j &amp;lt; pl &amp;amp;&amp;amp; p[j] == &#39;*&#39;){                      // 如果s已匹配完 p未完，如果p剩下字符为 * 则继续自增p的索引
            ++j;
        }
        if(j != pl)                                        // 如果p的索引没有走到末尾，则返回false.
            return false;
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;动态规划解法&#34;&gt;动态规划解法&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool isMatch(string s, string p) {
        vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; dp(p.size() + 1,vector&amp;lt;bool&amp;gt;(s.size() + 1,false));
        dp[0][0] = true;
        for(int i = 1; i &amp;lt;= p.size(); ++i){
            dp[i][0] = p[i - 1] == &#39;*&#39; ? dp[i - 1][0] : false;
            for(int j = 1; j &amp;lt;= s.size(); ++j){
                if(p[i - 1] == &#39;*&#39;){
                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
                }else if(p[i - 1] == &#39;?&#39; || p[i - 1] == s[j - 1]){
                    dp[i][j] = dp[i - 1][j - 1];
                }
            }
        }
        return dp[p.size()][s.size()];
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 43 - Multiply Strings [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/43-multiply-strings/</link>
      <pubDate>Thu, 11 Jul 2019 23:58:01 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/43-multiply-strings/</guid>
      <description>

&lt;h1 id=&#34;43-multiply-strings&#34;&gt;43.Multiply Strings&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/multiply-strings/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.&lt;/p&gt;

&lt;p&gt;给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;The length of both num1 and num2 is &amp;lt; 110.&lt;/li&gt;
&lt;li&gt;Both num1 and num2 contain only digits 0-9.&lt;/li&gt;
&lt;li&gt;Both num1 and num2 do not contain any leading zero, except the number 0 itself.&lt;/li&gt;
&lt;li&gt;You must not use any built-in BigInteger library or convert the inputs to integer directly.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; num1 = &amp;ldquo;2&amp;rdquo;, num2 = &amp;ldquo;3&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;6&amp;rdquo;&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; num1 = &amp;ldquo;123&amp;rdquo;, num2 = &amp;ldquo;456&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;56088&amp;rdquo;&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;两个字符串位数从右往左数，第一个数的第i位与第二个数的第j位相乘，会影响乘积的第i+j和第i+j-1位。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 74.92% of C++ online submissions for Multiply Strings.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9 MB, less than 39.84% of C++ online submissions for Multiply Strings.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    string multiply(string num1, string num2) {
        if(num1 == &amp;quot;0&amp;quot; || num2 == &amp;quot;0&amp;quot;) return &amp;quot;0&amp;quot;;
        int len1 = num1.size(), len2 = num2.size(),tmpl;
        string res = &amp;quot;&amp;quot;;
        vector&amp;lt;int&amp;gt; tmp(len1 + len2);
        for(int i = len1 - 1; i &amp;gt;= 0; --i){
            tmpl = len1 + len2 - 2 - i;
            for(int j = len2 - 1; j &amp;gt;= 0; --j){
                tmp[tmpl - j] += (num1[i] - 48) * (num2[j] - 48);
            }
        }
        for(int i = 0; i &amp;lt; len1 + len2 - 1; ++i){
            tmp[i + 1] += tmp[i] / 10;
            tmp[i] %= 10;
            res.insert(0,1,tmp[i] + 48);
        }
        if(0 != tmp[len1 + len2 - 1])
            res.insert(0,1,tmp[len1 + len2 - 1] + 48);
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 42 - Trapping Rain Water [Hard]</title>
      <link>https://cuckooemm.xyz/2019/july/42-trapping-rain-water/</link>
      <pubDate>Thu, 11 Jul 2019 21:48:35 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/42-trapping-rain-water/</guid>
      <description>

&lt;h1 id=&#34;42-trapping-rain-water&#34;&gt;42.Trapping Rain Water&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/trapping-rain-water/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Hard&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.&lt;/p&gt;

&lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [0,1,0,2,1,0,1,3,2,1,2,1]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 6&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;使用双指针指向两端，积水高度由两边指针决定。&lt;br /&gt;
遍历时维护lmax和rmax，如果当前高度低于*max，则计算积水量。&lt;br /&gt;
如果当前高度高于或等于*max，则更改lmax(rmax)。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 72.98% of C++ online submissions for Trapping Rain Water.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9 MB, less than 86.30% of C++ online submissions for Trapping Rain Water.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int trap(vector&amp;lt;int&amp;gt;&amp;amp; height) {
        int l = 0, r = height.size() - 1;
        int res  = 0;
        int lmax = 0, rmax = 0;
        while(l &amp;lt; r){
            if(height[l] &amp;lt; height[r]){
                if(height[l] &amp;gt;= lmax)
                    lmax = height[l];
                else
                    res += lmax - height[l];
                ++l;
            }else{
                if(height[r] &amp;gt;= rmax)
                    rmax = height[r];
                else
                    res += rmax - height[r];
                --r;
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 41 - First Missing Positive [Hard]</title>
      <link>https://cuckooemm.xyz/2019/july/41-first-missing-positive/</link>
      <pubDate>Thu, 11 Jul 2019 13:09:57 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/41-first-missing-positive/</guid>
      <description>

&lt;h1 id=&#34;41-first-missing-positive&#34;&gt;41.First Missing Positive&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/first-missing-positive/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Hard&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given an unsorted integer array, find the smallest missing positive integer.&lt;/p&gt;

&lt;p&gt;给定一个未排序的整数数组，找出其中没有出现的最小的正整数。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,2,0]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 3&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [3,4,-1,1]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 2&lt;/p&gt;

&lt;h4 id=&#34;example-3&#34;&gt;Example 3:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [7,8,9,11,12]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 1&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;Your algorithm should run in O(n) time and uses constant extra space.&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;利用桶排序的思路。&lt;br /&gt;
负数与大于数组长度的数字不考虑。&lt;br /&gt;
用数组中的数当作索引，存放在nums[i] - 1 的索引位置。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 0 ms, faster than 100.00% of C++ online submissions for First Missing Positive.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 30.44% of C++ online submissions for First Missing Positive.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int firstMissingPositive(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        if(nums.size() &amp;lt; 1)
            return 1;
        for(int i = 0; i &amp;lt; nums.size(); ++i){
            while(nums[i] &amp;gt; 0 &amp;amp;&amp;amp; nums[i] &amp;lt;= nums.size() &amp;amp;&amp;amp; nums[nums[i] - 1] != nums[i]){
                swap(nums[i],nums[nums[i] - 1]);
            }
        }
        for(int i = 0; i &amp;lt; nums.size(); ++i){
            if(nums[i] != i + 1){
                return i + 1;
            }
        }
        return nums.size() + 1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 40 - Combination Sum II [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/40-combination-sum-ii/</link>
      <pubDate>Tue, 09 Jul 2019 22:22:41 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/40-combination-sum-ii/</guid>
      <description>

&lt;h1 id=&#34;40-combination-sum-ii&#34;&gt;40.Combination Sum II&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum-ii/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.&lt;/p&gt;

&lt;p&gt;Each number in candidates may only be used once in the combination.&lt;/p&gt;

&lt;p&gt;给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。&lt;/p&gt;

&lt;p&gt;candidates 中的每个数字在每个组合中只能使用一次。&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The solution set must not contain duplicate combinations.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所有数字（包括目标数）都是正整数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解集不能包含重复的组合。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; candidates = [10,1,2,7,6,1,5], target = 8,&lt;br /&gt;
A solution set is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; candidates = [2,5,2,1,2], target = 5,&lt;br /&gt;
A solution set is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[
  [1,2,2],
  [5]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;与Combination Sum 方法一致，因不包含重复项所以递归时从当前push数组下标的下一个位置开始。排序解决重复项问题。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 99.44% of C++ online submissions for Combination Sum II.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9.1 MB, less than 59.13% of C++ online submissions for Combination Sum II.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
private:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    vector&amp;lt;int&amp;gt; tmp;
    void dfs(vector&amp;lt;int&amp;gt;&amp;amp; candidates,int target,int index){
        if(target == 0)
            return res.push_back(tmp);
        for(int i = index; i &amp;lt; candidates.size(); ++i){
            if(candidates[i] &amp;gt; target) break;
            if(index != i &amp;amp;&amp;amp; candidates[i] == candidates[i - 1])
                continue;
            tmp.push_back(candidates[i]);
            dfs(candidates,target - candidates[i],i + 1);            // 数字只能选取一次，从当前索引位置+1
            tmp.pop_back();
        }
    }
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum2(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) {
        sort(candidates.begin(),candidates.end());
        dfs(candidates,target,0);
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 39 - Combination Sum [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/39-combination-sum/</link>
      <pubDate>Tue, 09 Jul 2019 16:25:26 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/39-combination-sum/</guid>
      <description>

&lt;h1 id=&#34;39-combination-sum&#34;&gt;39.Combination Sum&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.&lt;/p&gt;

&lt;p&gt;The same repeated number may be chosen from candidates unlimited number of times.&lt;/p&gt;

&lt;p&gt;给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。&lt;/p&gt;

&lt;p&gt;candidates 中的数字可以无限制重复被选取。&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The solution set must not contain duplicate combinations.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所有数字（包括 target）都是正整数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解集不能包含重复的组合。 &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; candidates = [2,3,6,7], target = 7,&lt;br /&gt;
A solution set is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[  
  [7],  
  [2,2,3]  
]  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; candidates = [2,3,5], target = 8,&lt;br /&gt;
A solution set is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[  
  [2,2,2,2],  
  [2,3,3],  
  [3,5]  
]  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;递归回溯。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 98.70% of C++ online submissions for Combination Sum.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9.7 MB, less than 58.59% of C++ online submissions for Combination Sum.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
private:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    vector&amp;lt;int&amp;gt; temp;
    void dfs(vector&amp;lt;int&amp;gt;&amp;amp; candidates,int target,int index){
        if(target == 0)
            return res.push_back(temp);
        for(; index &amp;lt; candidates.size(); ++index){
            if(candidates[index] &amp;gt; target) continue;
            temp.push_back(candidates[index]);
            dfs(candidates,target - candidates[index],index);        // 数字可被无限次选取，沿用当前位置索引
            temp.pop_back();
        }
    }
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) {
        dfs(candidates,target,0);
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 38 - Count and Say [Easy]</title>
      <link>https://cuckooemm.xyz/2019/july/38-count-and-say/</link>
      <pubDate>Mon, 08 Jul 2019 17:32:57 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/38-count-and-say/</guid>
      <description>

&lt;h1 id=&#34;38-count-and-say&#34;&gt;38.Count and Say&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/count-and-say/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;The count-and-say sequence is the sequence of integers with the first five terms as following:&lt;/p&gt;

&lt;p&gt;报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;     1
     11
     21
     1211
     111221
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;1 is read off as &amp;ldquo;one 1&amp;rdquo; or 11.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;11 is read off as &amp;ldquo;two 1s&amp;rdquo; or 21.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;21 is read off as &amp;ldquo;one 2, then one 1&amp;rdquo; or 1211.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;1 被读作  &amp;rdquo;one 1&amp;rdquo;  (&amp;ldquo;一个一&amp;rdquo;) , 即 11。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;11 被读作 &amp;rdquo;two 1s&amp;rdquo; (&amp;ldquo;两个一&amp;rdquo;）, 即 21。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;21 被读作 &amp;rdquo;one 2&amp;rdquo;,  &amp;rdquo;one 1&amp;rdquo; （&amp;rdquo;一个二&amp;rdquo; ,  &amp;rdquo;一个一&amp;rdquo;) , 即 1211。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.&lt;/p&gt;

&lt;p&gt;给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。&lt;/p&gt;

&lt;h4 id=&#34;note-each-term-of-the-sequence-of-integers-will-be-represented-as-a-string&#34;&gt;Note: Each term of the sequence of integers will be represented as a string.&lt;/h4&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 1&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;1&amp;rdquo;&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 4&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;1211&amp;rdquo;&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;使用循环依次计算后项。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 0 ms, faster than 100.00% of C++ online submissions for Count and Say.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 80.15% of C++ online submissions for Count and Say.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    string countAndSay(int n) {
        string curRes = &amp;quot;1&amp;quot;;
        string res = &amp;quot;&amp;quot;;
        int curIndex = 2,count = 1;
        while(curIndex &amp;lt;= n){
            res = &amp;quot;&amp;quot;;
            for(int i = 0; i &amp;lt; curRes.size(); ++i){
                if(i+1 &amp;lt; curRes.size() &amp;amp;&amp;amp; curRes[i] == curRes[i + 1]){
                    ++count;
                }else{
                    res.push_back(count + 48);
                    res.push_back(curRes[i]);
                    count = 1;
                }
            }
            curRes = res;
            ++curIndex;
        }
        return curRes;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 35 - Search Insert Position [Easy]</title>
      <link>https://cuckooemm.xyz/2019/july/35-search-insert-position/</link>
      <pubDate>Sun, 07 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/35-search-insert-position/</guid>
      <description>

&lt;h1 id=&#34;35-search-insert-position&#34;&gt;35.Search Insert Position&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-insert-position/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.&lt;/p&gt;

&lt;p&gt;You may assume no duplicates in the array.&lt;/p&gt;

&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;

&lt;p&gt;你可以假设数组中无重复元素。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,3,5,6], 5&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 2&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,3,5,6], 2&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 1&lt;/p&gt;

&lt;h4 id=&#34;example-3&#34;&gt;Example 3:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,3,5,6], 7&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 4&lt;/p&gt;

&lt;h4 id=&#34;example-4&#34;&gt;Example 4:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,3,5,6], 0&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 0&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;二分法。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 74.90% of C++ online submissions for Search Insert Position.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.9 MB, less than 59.90% of C++ online submissions for Search Insert Position.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
        int mid = 0, l = 0, r = nums.size() - 1;
        while(l &amp;lt;= r){
            mid = (r - l &amp;gt;&amp;gt; 1) + l;
            if(nums[mid] == target)
                return mid;
            else if(nums[mid] &amp;gt; target)
                r = mid - 1;
            else
                l = mid + 1;
        }
        return l;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>