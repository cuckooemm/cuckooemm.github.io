<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cuckooemm&#39;s Blog on Cuckooemm&#39;s Blog</title>
    <link>https://cuckooemm.xyz/</link>
    <description>Recent content in Cuckooemm&#39;s Blog on Cuckooemm&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 06 Jul 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Leetcode - 33 - Search in Rotated Sorted Array [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/33-search-in-rotated-sorted-array/</link>
      <pubDate>Sat, 06 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/33-search-in-rotated-sorted-array/</guid>
      <description>

&lt;h1 id=&#34;33-search-in-rotated-sorted-array&#34;&gt;33.Search in Rotated Sorted Array&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-in-rotated-sorted-array/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;/p&gt;

&lt;p&gt;(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).&lt;/p&gt;

&lt;p&gt;You are given a target value to search. If found in the array return its index, otherwise return -1.&lt;/p&gt;

&lt;p&gt;You may assume no duplicate exists in the array.&lt;/p&gt;

&lt;p&gt;Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).&lt;/p&gt;

&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;

&lt;p&gt;( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。&lt;/p&gt;

&lt;p&gt;搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。&lt;/p&gt;

&lt;p&gt;你可以假设数组中不存在重复的元素。&lt;/p&gt;

&lt;p&gt;你的算法时间复杂度必须是 O(log n) 级别。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; nums = [4,5,6,7,0,1,2], target = 0&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 4&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; nums = [4,5,6,7,0,1,2], target = 3&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; -1&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;题目要求 O(log n) 级别复杂度，所以采用&lt;strong&gt;二分法&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 0 ms, faster than 100.00% of C++ online submissions for Search in Rotated Sorted Array.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.5 MB, less than 99.60% of C++ online submissions for Search in Rotated Sorted Array.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
        int l = 0,r = nums.size() - 1;
        int mid = 0;
        while(l &amp;lt;= r){
            mid = (r - l &amp;gt;&amp;gt; 1) + l;                             // 防止加法溢出
            if(nums[mid] == target) return mid; 
            if(nums[mid] &amp;gt;= nums[l]){                           // 说明mid左边有序
                if(nums[mid] &amp;gt; target &amp;amp;&amp;amp; nums[l] &amp;lt;= target)     // 查看mid是否在左区间
                    r = mid - 1;
                else
                    l = mid + 1;
            }else{                                              // 等同 mid &amp;lt; r
                if(nums[mid] &amp;lt; target &amp;amp;&amp;amp; nums[r] &amp;gt;= target)     // 查看mid是否在右区间
                    l = mid + 1;
                else
                    r = mid - 1;
            }
        }
        return -1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 34 - Find First and Last Position of Element in Sorted Array [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/34-find-first-and-last-position-of-element-in-sorted-array/</link>
      <pubDate>Sat, 06 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/34-find-first-and-last-position-of-element-in-sorted-array/</guid>
      <description>

&lt;h1 id=&#34;34-find-first-and-last-position-of-element-in-sorted-array&#34;&gt;34.Find First and Last Position of Element in Sorted Array&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.&lt;/p&gt;

&lt;p&gt;Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).&lt;/p&gt;

&lt;p&gt;If the target is not found in the array, return [-1, -1].&lt;/p&gt;

&lt;p&gt;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。&lt;/p&gt;

&lt;p&gt;你的算法时间复杂度必须是 O(log n) 级别。&lt;/p&gt;

&lt;p&gt;如果数组中不存在目标值，返回 [-1, -1]。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; nums = [5,7,7,8,8,10], target = 8&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; [3,4]&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; nums = [5,7,7,8,8,10], target = 6&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; [-1,-1]&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;题目要求 O(log n) 级别复杂度，所以采用&lt;strong&gt;二分法&lt;/strong&gt;。&lt;br /&gt;
先找到target的索引，然后以此为中心，在左半区找最小索引，右半区找最大索引。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 90.94% of C++ online submissions for Find First and Last Position of Element in Sorted Array.&lt;/li&gt;
&lt;li&gt;Memory Usage: 10.2 MB, less than 76.14% of C++ online submissions for Find First and Last Position of Element in Sorted Array.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; searchRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
        int mid = 0, l = 0, r = nums.size() - 1;
        int lm = l, rm = r;
        vector&amp;lt;int&amp;gt; res(2,-1);
        while(l &amp;lt;= r){
            mid = (r - l &amp;gt;&amp;gt; 1) + l;
            if(nums[mid] == target){
                lm = mid;
                rm = mid;
                while(l &amp;lt;= lm){                 // 在[l,lm]中找最小索引
                    mid = (lm - l &amp;gt;&amp;gt; 1) + l;
                    if(nums[mid] == target){
                        lm = mid - 1;
                        res[0] = mid;
                    }else
                        l = mid + 1;
                }
                while(rm &amp;lt;= r){                 // 在[rm,r]中找最大索引
                    mid = (r - rm &amp;gt;&amp;gt; 1) + rm;
                    if(nums[mid] == target){
                        rm = mid + 1;
                        res[1] = mid;
                    }else
                        r = mid - 1;
                }
                break;                          // 跳出循环
            }else if(target &amp;gt; nums[mid]){
                l = mid + 1;
            }else
                r = mid - 1;
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang 代理</title>
      <link>https://cuckooemm.xyz/2019/july/golang-%E4%BB%A3%E7%90%86/</link>
      <pubDate>Fri, 05 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/golang-%E4%BB%A3%E7%90%86/</guid>
      <description>

&lt;h1 id=&#34;解决golang依赖网络问题&#34;&gt;解决golang依赖网络问题&lt;/h1&gt;

&lt;p&gt;添加环境变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;key: GOPROXY     value: https://goproxy.io
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 29 - Divide Two Integers [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/29-divide-two-integers/</link>
      <pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/29-divide-two-integers/</guid>
      <description>

&lt;h1 id=&#34;29-divide-two-integers&#34;&gt;29.Divide Two Integers&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/divide-two-integers/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.&lt;/p&gt;

&lt;p&gt;Return the quotient after dividing dividend by divisor.&lt;/p&gt;

&lt;p&gt;The integer division should truncate toward zero.&lt;/p&gt;

&lt;p&gt;给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。&lt;/p&gt;

&lt;p&gt;返回被除数 dividend 除以除数 divisor 得到的商。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; dividend = 10, divisor = 3&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 3&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; dividend = 7, divisor = -3&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; -2&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;Both dividend and divisor will be 32-bit signed integers.&lt;br /&gt;
The divisor will never be 0.&lt;br /&gt;
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2&lt;sup&gt;31&lt;/sup&gt;,  2&lt;sup&gt;31&lt;/sup&gt; − 1].
For the purpose of this problem, assume that your function returns 2&lt;sup&gt;31&lt;/sup&gt; − 1 when the division result overflows.&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;余数可以用被除数减去除数求得。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;每次减完除数翻倍，倍数记录翻的倍数。如果当前除数大于被除数，则缩小。位移操作实现。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;异或判断符号。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(log(n)), 空间复杂度：O(1)。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 93.13% of C++ online submissions for Divide Two Integers.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.3 MB, less than 53.98% of C++ online submissions for Divide Two Integers.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int divide(int dividend, int divisor) {
        if(dividend == -2147483648 &amp;amp;&amp;amp; divisor == -1) return INT_MAX;   // 溢出的输入直接返回
        if(divisor == 1) return dividend;                              // 除数为1直接返回
        long long dd = abs((long long)dividend);                       // -2147483648 的绝对值大于int类型的最大整数
        long long dr = abs((long long)divisor);
        int res = 0;                                                   // 保存结果
        int times = 1;                                                 // 倍数
        while(dd &amp;gt;= dr || times &amp;gt; 1){
            if(dd &amp;gt;= dr){
                dd -= dr;
                res += times;
                dr = dr &amp;lt;&amp;lt; 1;                                          // 除数扩大一倍
                times = times &amp;lt;&amp;lt; 1;                                    // 倍数也扩大一倍
            }else{
                dr = dr &amp;gt;&amp;gt; 1;                                          // 除数缩小一倍
                times = times &amp;gt;&amp;gt; 1;                                    // 倍数缩小一倍
            }
        }
        return (dividend ^ divisor) &amp;gt;= 0 ? res : -res;                 // 异或判断符号是否不等
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 31 - Next Permutation [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/31-next-permutation/</link>
      <pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/31-next-permutation/</guid>
      <description>

&lt;h1 id=&#34;31-next-permutation&#34;&gt;31.Next Permutation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/next-permutation/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.&lt;/p&gt;

&lt;p&gt;If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).&lt;/p&gt;

&lt;p&gt;The replacement must be in-place and use only constant extra memory.&lt;/p&gt;

&lt;p&gt;Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.&lt;/p&gt;

&lt;p&gt;实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。&lt;/p&gt;

&lt;p&gt;如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。&lt;/p&gt;

&lt;p&gt;必须原地修改，只允许使用额外常数空间。&lt;/p&gt;

&lt;p&gt;以下是一些例子，输入位于左侧列，其相应输出位于右侧列。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;p&gt;1,2,3 → 1,3,2&lt;br /&gt;
3,2,1 → 1,2,3&lt;br /&gt;
1,1,5 → 1,5,1&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;从右往左遍历，如果i小于i+1的值则退出循环。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在i到end的区间内寻找最小的大于当前i位置值的数交换。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;反转i之后的数字。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 92.20% of C++ online submissions for Next Permutation.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 55.56% of C++ online submissions for Next Permutation.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    void nextPermutation(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int i = nums.size() - 2;
        while(i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[i + 1]){
            --i;
        }
        if(i &amp;gt;= 0){
            int j = nums.size() - 1;
            while(j &amp;gt; i &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[j]){
                --j;
            }
            swap(nums[i],nums[j]);
        }
        reverse(nums,i + 1);
    }
    void reverse(vector&amp;lt;int&amp;gt;&amp;amp; nums,int start){
        int r = nums.size() - 1;
        while(start &amp;lt; r){
            swap(nums[start],nums[r]);
            ++start;
            --r;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 27 - Remove Element [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/27-remove-element/</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/27-remove-element/</guid>
      <description>

&lt;h1 id=&#34;27-remove-element&#34;&gt;27.Remove Element&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/remove-element/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given an array nums and a value val, remove all instances of that value in-place and return the new length.&lt;/p&gt;

&lt;p&gt;Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.&lt;/p&gt;

&lt;p&gt;The order of elements can be changed. It doesn&amp;rsquo;t matter what you leave beyond the new length.&lt;/p&gt;

&lt;p&gt;给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。&lt;/p&gt;

&lt;p&gt;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;

&lt;p&gt;元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;Given nums = [3,2,2,3], val = 3,&lt;/p&gt;

&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 2.&lt;/p&gt;

&lt;p&gt;It doesn&amp;rsquo;t matter what you leave beyond the returned length.&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;Given nums = [0,1,2,2,3,0,4,2], val = 2,&lt;/p&gt;

&lt;p&gt;Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.&lt;/p&gt;

&lt;p&gt;Note that the order of those five elements can be arbitrary.&lt;/p&gt;

&lt;p&gt;It doesn&amp;rsquo;t matter what values are set beyond the returned length.&lt;/p&gt;

&lt;h4 id=&#34;clarification&#34;&gt;Clarification:&lt;/h4&gt;

&lt;p&gt;Confused why the returned value is an integer but your answer is an array?&lt;/p&gt;

&lt;p&gt;Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.&lt;/p&gt;

&lt;p&gt;Internally you can think of this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// nums is passed in by reference. (i.e., without making a copy)
int len = removeElement(nums, val);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i &amp;lt; len; i++) {
    print(nums[i]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;遍历nums,如果数组内值与目标值不等，且当前已经出现过目标值，则把i位置的值赋给l位置。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(1)。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 89.95% of C++ online submissions for Remove Element.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 54.44% of C++ online submissions for Remove Element.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int removeElement(vector&amp;lt;int&amp;gt;&amp;amp; nums, int val) {
        int l = 0;
        for(int i = 0; i &amp;lt; nums.size(); ++i){
            if(nums[i] != val){
                if(i != l){
                    nums[l++] = nums[i];
                }else{
                    ++l;
                }
            }
        }
        return l;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 28 - Implment StrStr() [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/28-implment-strstr/</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/28-implment-strstr/</guid>
      <description>

&lt;h1 id=&#34;28-implment-strstr&#34;&gt;28.Implment StrStr()&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/implement-strstr/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Implement strStr().&lt;/p&gt;

&lt;p&gt;Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack&lt;/p&gt;

&lt;p&gt;实现 strStr() 函数。&lt;/p&gt;

&lt;p&gt;给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; haystack = &amp;ldquo;hello&amp;rdquo;, needle = &amp;ldquo;ll&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 2&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; haystack = &amp;ldquo;aaaaa&amp;rdquo;, needle = &amp;ldquo;bba&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; -1&lt;/p&gt;

&lt;h4 id=&#34;clarification&#34;&gt;Clarification:&lt;/h4&gt;

&lt;p&gt;What should we return when needle is an empty string? This is a great question to ask during an interview.&lt;/p&gt;

&lt;p&gt;For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C&amp;rsquo;s strstr() and Java&amp;rsquo;s indexOf().&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;haystack字符串减去needle字符串长度减少循环的次数。&lt;br /&gt;
如果当前haystack字符串中有字符等于needle的首字符，则开启循环遍历。&lt;br /&gt;
如果循环的次数等于needle字符串长度，则说明字符串匹配，返回开始匹配的首字符的索引。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n*j), 空间复杂度：O(1)。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 97.03% of C++ online submissions for Implement strStr().&lt;/li&gt;
&lt;li&gt;Memory Usage: 9.1 MB, less than 74.01% of C++ online submissions for Implement strStr().&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int strStr(string haystack, string needle) {
        int lenh = haystack.size();
        int lenn = needle.size();
        if(lenn == 0) return 0;
        for(int i = 0; i &amp;lt;= lenh - lenn; ++i){
            if(haystack[i] == needle[0]){
                for(int j = 0; j &amp;lt; lenn &amp;amp;&amp;amp; haystack[i + j] == needle[j]; ++j)
                    if(j == lenn - 1) return i; 
            }
        }
        return -1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang 内存对齐</title>
      <link>https://cuckooemm.xyz/2019/june/golang-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/golang-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</guid>
      <description>

&lt;h1 id=&#34;golang-内存对齐&#34;&gt;Golang 内存对齐&lt;/h1&gt;

&lt;p&gt;golang结构体中变量的顺序不同为结构体分配的内存大小也不同。&lt;/p&gt;

&lt;p&gt;先来看一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Part1 struct {
	a bool
	b int32
	c int8
	d int64
	e byte
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;bool  一个字节&lt;/li&gt;
&lt;li&gt;int32 四个字节&lt;/li&gt;
&lt;li&gt;int8  一个字节&lt;/li&gt;
&lt;li&gt;int64 八个字节&lt;/li&gt;
&lt;li&gt;byte  一个字节&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以应分配的内存空间为&lt;code&gt;1 + 4 + 1 + 8 + 1 = 15&lt;/code&gt;个字节。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Part1 struct {
    a bool
	b int32
	c int8
	d int64
	e byte
}

func main() {
	part1 := Part1{}
	fmt.Printf(&amp;quot;part1 size: %d, align: %d\n&amp;quot;, unsafe.Sizeof(part1), unsafe.Alignof(part1))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;part1 size: 32, align: 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终输出占用内存为32字节，与前面的计算结果并不一致。&lt;br /&gt;
而造成这种情况的原因就是内存对齐。&lt;br /&gt;
接下来改变一下字段的顺序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Part1 struct {
	a bool
	b int32
	c int8
	d int64
	e byte
}

type Part2 struct {
	e byte
	c int8
	a bool
	b int32
	d int64
}

func main() {
	part1 := Part1{}
	part2 := Part2{}

	fmt.Printf(&amp;quot;part1 size: %d, align: %d\n&amp;quot;, unsafe.Sizeof(part1), unsafe.Alignof(part1))
	fmt.Printf(&amp;quot;part2 size: %d, align: %d\n&amp;quot;, unsafe.Sizeof(part2), unsafe.Alignof(part2))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;part1 size: 32, align: 8
part2 size: 16, align: 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发现，仅仅只是改变的结构体字段的顺序，内存占用的空间就减少了一半。&lt;/p&gt;

&lt;h3 id=&#34;为什么要内存对齐&#34;&gt;为什么要内存对齐&lt;/h3&gt;

&lt;p&gt;CPU读取主存是一件耗时的操作，所以CPU并不会一个一个字节的去内存读取数据，而是以块为单位在内存上读取数据。块的大小可以为：2、4、8、16 字节等大小，称其为内存访问粒度。如果访问未对齐的内存，一次访问能完成的事情便需要两次，并且为了提高内存的利用率，我们需要进行内存对齐。&lt;/p&gt;

&lt;h3 id=&#34;默认系数&#34;&gt;默认系数&lt;/h3&gt;

&lt;p&gt;在不同平台上的编译器都有自己默认的 “对齐系数”，可通过预编译命令 #pragma pack(n) 进行变更，n 就是代指 “对齐系数”。一般来讲，我们常用的平台的系数如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;32 位：4&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;64 位：8&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外要注意，不同硬件平台占用的大小和对齐值都可能是不一样的。&lt;/p&gt;

&lt;h3 id=&#34;成员对齐&#34;&gt;成员对齐&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {
	fmt.Printf(&amp;quot;bool align: %d\n&amp;quot;, unsafe.Alignof(bool(true)))
	fmt.Printf(&amp;quot;int32 align: %d\n&amp;quot;, unsafe.Alignof(int32(0)))
	fmt.Printf(&amp;quot;int8 align: %d\n&amp;quot;, unsafe.Alignof(int8(0)))
	fmt.Printf(&amp;quot;int64 align: %d\n&amp;quot;, unsafe.Alignof(int64(0)))
	fmt.Printf(&amp;quot;byte align: %d\n&amp;quot;, unsafe.Alignof(byte(0)))
	fmt.Printf(&amp;quot;string align: %d\n&amp;quot;, unsafe.Alignof(&amp;quot;EDDYCJY&amp;quot;))
	fmt.Printf(&amp;quot;map align: %d\n&amp;quot;, unsafe.Alignof(map[string]string{}))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;bool align: 1
int32 align: 4
int8 align: 1
int64 align: 8
byte align: 1
string align: 8
map align: 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Go 中可以调用 &lt;code&gt;unsafe.Alignof()&lt;/code&gt; 来返回相应类型的对齐系数。通过观察输出结果，可得知基本都是 2&lt;sup&gt;n&lt;/sup&gt;，最大也不会超过 8。64位机编译器默认对齐系数是 8，因此最大值不会超过这个数。&lt;/p&gt;

&lt;h3 id=&#34;对齐规则&#34;&gt;对齐规则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为编译器默认对齐长度（#pragma pack(n)）或当前成员变量类型的长度（unsafe.Sizeof），取最小值作为当前类型的对齐值。其偏移量必须为对齐值的整数倍&lt;/li&gt;
&lt;li&gt;结构体本身，对齐值必须为编译器默认对齐长度（#pragma pack(n)）或结构体的所有成员变量类型中的最大长度，取最大数的最小整数倍作为对齐值&lt;/li&gt;
&lt;li&gt;结合以上两点，可得知若编译器默认对齐长度（#pragma pack(n)）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;成员变量&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;类型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;偏移量&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;自身占用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;a&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bool&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;字节对齐&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;b&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;int32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;c&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;int8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;字节对齐&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;d&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;int64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;e&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;byte&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;24&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;字节对齐&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;25&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;总占用大小&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;内存分配分析&#34;&gt;内存分配分析&lt;/h3&gt;

&lt;h4 id=&#34;未进行内存对齐&#34;&gt;未进行内存对齐&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;第一个成员 a

&lt;ul&gt;
&lt;li&gt;类型为 bool&lt;/li&gt;
&lt;li&gt;大小/对齐值为 1 字节&lt;/li&gt;
&lt;li&gt;初始地址，偏移量为 0。占用了第 1 位&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第二个成员 b

&lt;ul&gt;
&lt;li&gt;类型为 int32&lt;/li&gt;
&lt;li&gt;大小/对齐值为 4 字节&lt;/li&gt;
&lt;li&gt;根据规则 1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此 2-4 位为 Padding。而当前数值从第 5 位开始填充，到第 8 位。如下：axxx|bbbb&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第三个成员 c

&lt;ul&gt;
&lt;li&gt;类型为 int8&lt;/li&gt;
&lt;li&gt;大小/对齐值为 1 字节&lt;/li&gt;
&lt;li&gt;根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 8。不需要额外对齐，填充 1 个字节到第 9 位。如下：axxx|bbbb|c&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第四个成员 d

&lt;ul&gt;
&lt;li&gt;类型为 int64&lt;/li&gt;
&lt;li&gt;大小/对齐值为 8 字节&lt;/li&gt;
&lt;li&gt;根据规则 1，其偏移量必须为 8 的整数倍。确定偏移量为 16，因此 9-16 位为 Padding。而当前数值从第 17 位开始写入，到第 24 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第五个成员 e

&lt;ul&gt;
&lt;li&gt;类型为 byte&lt;/li&gt;
&lt;li&gt;大小/对齐值为 1 字节&lt;/li&gt;
&lt;li&gt;根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 24。不需要额外对齐，填充 1 个字节到第 25 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd|e&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;内存对齐之后&#34;&gt;内存对齐之后&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;第一个成员 e

&lt;ul&gt;
&lt;li&gt;类型为 byte&lt;/li&gt;
&lt;li&gt;大小/对齐值为 1 字节&lt;/li&gt;
&lt;li&gt;初始地址，偏移量为 0。占用了第 1 位&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第二个成员 c

&lt;ul&gt;
&lt;li&gt;类型为 int8&lt;/li&gt;
&lt;li&gt;大小/对齐值为 1 字节&lt;/li&gt;
&lt;li&gt;根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 2。不需要额外对齐&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第三个成员 a

&lt;ul&gt;
&lt;li&gt;类型为 bool&lt;/li&gt;
&lt;li&gt;大小/对齐值为 1 字节&lt;/li&gt;
&lt;li&gt;根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 3。不需要额外对齐&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第四个成员 b

&lt;ul&gt;
&lt;li&gt;类型为 int32&lt;/li&gt;
&lt;li&gt;大小/对齐值为 4 字节&lt;/li&gt;
&lt;li&gt;根据规则1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此第 3 位为 Padding。而当前数值从第 4 位开始填充，到第 8 位。如下：ecax|bbbb&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第五个成员 d

&lt;ul&gt;
&lt;li&gt;类型为 int64&lt;/li&gt;
&lt;li&gt;大小/对齐值为 8 字节&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Part1 内存布局：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx&lt;br /&gt;
Part2 内存布局：ecax|bbbb|dddd|dddd&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 25 - Reverse Nodes in k Group [Hard]</title>
      <link>https://cuckooemm.xyz/2019/june/25-reverse-nodes-in-k-group/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/25-reverse-nodes-in-k-group/</guid>
      <description>

&lt;h1 id=&#34;25-reverse-nodes-in-k-group&#34;&gt;25.Reverse Nodes in k Group&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/reverse-nodes-in-k-group/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Hard&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.&lt;/p&gt;

&lt;p&gt;k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.&lt;/p&gt;

&lt;p&gt;给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。&lt;/p&gt;

&lt;p&gt;k 是一个正整数，它的值小于或等于链表的长度。&lt;/p&gt;

&lt;p&gt;如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。&lt;/p&gt;

&lt;h3 id=&#34;实例&#34;&gt;实例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;Given this linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5&lt;/p&gt;

&lt;p&gt;For k = 2, you should return: 2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5&lt;/p&gt;

&lt;p&gt;For k = 3, you should return: 3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;Only constant extra memory is allowed.&lt;br /&gt;
You may not alter the values in the list&amp;rsquo;s nodes, only nodes itself may be changed.&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;首先循环k次，则k以前的链表则是需要交换的链表。&lt;br /&gt;
可以使用递归的方法，&lt;strong&gt;空间复杂度O(k)。&lt;/strong&gt;&lt;br /&gt;
在这里使用了指针交换的方法。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(1)。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 20 ms, faster than 91.59% of C++ online submissions for Reverse Nodes in k-Group.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9.9 MB, less than 56.39% of C++ online submissions for Reverse Nodes in k-Group.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(head == NULL) return head;
        ListNode* res = new ListNode(0);
        ListNode* cur = head;
        res-&amp;gt;next = head;
        ListNode* resc = res;
        ListNode* curp;
        while(head != NULL){
            cur = head;
            for(int i = 0; i &amp;lt; k; ++i){                // 判断下一个轮是否够k个数
                if(head == NULL) return  res-&amp;gt;next;
                head = head-&amp;gt;next;
            }
            for(int i = 1; i &amp;lt; k; ++i){                // N数只需交换n-1次
                curp = cur-&amp;gt;next;
                cur-&amp;gt;next = curp-&amp;gt;next;
                curp-&amp;gt;next = resc-&amp;gt;next;
                resc-&amp;gt;next = curp;                
            }
            for(int i = 0; i &amp;lt; k; ++i){
                resc = resc-&amp;gt;next;                     // 更新头部指针
            }
        }
        return res-&amp;gt;next;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 26 - Remove Duplicates From Sorted Array [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/26-remove-duplicates-from-sorted-array/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/26-remove-duplicates-from-sorted-array/</guid>
      <description>

&lt;h1 id=&#34;26-remove-duplicates-from-sorted-array&#34;&gt;26.Remove Duplicates From Sorted Array&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/remove-duplicates-from-sorted-array/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.&lt;/p&gt;

&lt;p&gt;Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.&lt;/p&gt;

&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;/p&gt;

&lt;p&gt;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;Given nums = [1,1,2],&lt;/p&gt;

&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.&lt;/p&gt;

&lt;p&gt;It doesn&amp;rsquo;t matter what you leave beyond the returned length.&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;Given nums = [0,0,1,1,1,2,2,3,3,4],&lt;/p&gt;

&lt;p&gt;Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.&lt;/p&gt;

&lt;p&gt;It doesn&amp;rsquo;t matter what values are set beyond the returned length.&lt;/p&gt;

&lt;h4 id=&#34;clarification&#34;&gt;Clarification:&lt;/h4&gt;

&lt;p&gt;Confused why the returned value is an integer but your answer is an array?&lt;/p&gt;

&lt;p&gt;Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.&lt;/p&gt;

&lt;p&gt;Internally you can think of this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i &amp;lt; len; i++) {
    print(nums[i]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;因数组有序，定义左指针，当不相等时左指针加一，又因两个指针起点不一，把左指针的右边一位数重新赋值为最右边指针的数据。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(1)。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 16 ms, faster than 99.66% of C++ online submissions for Remove Duplicates from Sorted Array.&lt;/li&gt;
&lt;li&gt;Memory Usage: 10 MB, less than 50.23% of C++ online submissions for Remove Duplicates from Sorted Array.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        if(nums.size() &amp;lt; 1) return 0;
        int l = 0;
        for(int i = 1; i &amp;lt; nums.size(); ++i){
            if(nums[l] != nums[i])
                nums[++l] = nums[i];
        }
        return ++l;
    }   
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 24 - Swap Nodes in Pairs [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/24-swap-nodes-in-pairs/</link>
      <pubDate>Fri, 07 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/24-swap-nodes-in-pairs/</guid>
      <description>

&lt;h1 id=&#34;24-swap-nodes-in-pairs&#34;&gt;24.Swap Nodes in Pairs&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/swap-nodes-in-pairs/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a linked list, swap every two adjacent nodes and return its head.&lt;/p&gt;

&lt;p&gt;You may not modify the values in the list&amp;rsquo;s nodes, only nodes itself may be changed.&lt;/p&gt;

&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;/p&gt;

&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, you should return the list as 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;交换指针。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(1)。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 0 ms, faster than 100.00% of C++ online submissions for Swap Nodes in Pairs.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.8 MB, less than 47.42% of C++ online submissions for Swap Nodes in Pairs.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head == NULL) return head;
        ListNode* cur = new ListNode(0);
        ListNode* res = cur;
        res-&amp;gt;next = head;
        ListNode* temp;
        while(head){
            if(head-&amp;gt;next == NULL) break;
                temp = head;
                cur-&amp;gt;next = head-&amp;gt;next;
                cur = cur-&amp;gt;next;
                head = head-&amp;gt;next-&amp;gt;next;
                cur-&amp;gt;next = temp;
                cur = cur-&amp;gt;next;
                cur-&amp;gt;next = head;
            
        }
        return res-&amp;gt;next;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 23 - Merge k Sorted Lists [Hard]</title>
      <link>https://cuckooemm.xyz/2019/june/23-merge-k-sorted-lists/</link>
      <pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/23-merge-k-sorted-lists/</guid>
      <description>

&lt;h1 id=&#34;23-merge-k-sorted-lists&#34;&gt;23.Merge k Sorted Lists&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/merge-k-sorted-lists/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Hard&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.&lt;/p&gt;

&lt;p&gt;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;

&lt;h3 id=&#34;实例&#34;&gt;实例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;br /&gt;
[&lt;br /&gt;
  1-&amp;gt;4-&amp;gt;5,&lt;br /&gt;
  1-&amp;gt;3-&amp;gt;4,&lt;br /&gt;
  2-&amp;gt;6&lt;br /&gt;
]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;使用优先队列解决。
&lt;strong&gt;时间复杂度:O(n log k), 空间复杂度：O(k)。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 20 ms, faster than 99.55% of C++ online submissions for Merge k Sorted Lists.&lt;/li&gt;
&lt;li&gt;Memory Usage: 11.3 MB, less than 65.67% of C++ online submissions for Merge k Sorted Lists.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
private:
    struct cmp{
        bool operator()(ListNode* l,ListNode* r){
            return l-&amp;gt;val &amp;gt; r-&amp;gt;val;
        }
    };
public:
    ListNode* mergeKLists(vector&amp;lt;ListNode*&amp;gt;&amp;amp; lists) {
        if(lists.empty()) return NULL;
        priority_queue&amp;lt;ListNode*,vector&amp;lt;ListNode*&amp;gt;,cmp&amp;gt; p;
        ListNode* head = new ListNode(0);
        ListNode* cur = head;
        for(int i = 0; i &amp;lt; lists.size(); ++i){
            if(lists[i] != NULL){                  // 不为空加入优先队列
                p.push(lists[i]);
            }
        }
        while(!p.empty()){
            cur-&amp;gt;next = p.top();
            cur = cur-&amp;gt;next;
            p.pop();
            if(cur-&amp;gt;next != NULL){
                p.push(cur-&amp;gt;next);         
            }
        }
        return head-&amp;gt;next;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 17 - Letter Combinations of a Phone Number [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/17-letter-combinations-of-a-phone-number/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/17-letter-combinations-of-a-phone-number/</guid>
      <description>

&lt;h1 id=&#34;17-letter-combinations-of-a-phone-number&#34;&gt;17.Letter Combinations of a Phone Number&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/letter-combinations-of-a-phone-number/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a string containing digits from &lt;code&gt;2-9&lt;/code&gt; inclusive, return all possible letter combinations that the number could represent.&lt;/p&gt;

&lt;p&gt;A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.&lt;/p&gt;

&lt;p&gt;给定一个仅包含数字 &lt;code&gt;2-9&lt;/code&gt; 的字符串，返回所有它能表示的字母组合。&lt;/p&gt;

&lt;p&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; &amp;ldquo;23&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; [&amp;ldquo;ad&amp;rdquo;, &amp;ldquo;ae&amp;rdquo;, &amp;ldquo;af&amp;rdquo;, &amp;ldquo;bd&amp;rdquo;, &amp;ldquo;be&amp;rdquo;, &amp;ldquo;bf&amp;rdquo;, &amp;ldquo;cd&amp;rdquo;, &amp;ldquo;ce&amp;rdquo;, &amp;ldquo;cf&amp;rdquo;].&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;Although the above answer is in lexicographical order, your answer could be in any order you want.&lt;br /&gt;
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;递归实现。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(3&lt;sup&gt;n&lt;/sup&gt; * 4&lt;sup&gt;m&lt;/sup&gt;), 空间复杂度：O(3&lt;sup&gt;n&lt;/sup&gt; * 4&lt;sup&gt;m&lt;/sup&gt;)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 0 ms, faster than 100.00% of C++ online submissions for Letter Combinations of a Phone Number.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 50.00% of C++ online submissions for Letter Combinations of a Phone Number.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
private:
    string phone(char i){
        switch(i){
            case &#39;2&#39; :
                return &amp;quot;abc&amp;quot;;
                break;
            case &#39;3&#39; :
                return &amp;quot;def&amp;quot;;
                break;
            case &#39;4&#39; :
                return &amp;quot;ghi&amp;quot;;
                break;
            case &#39;5&#39; :
                return &amp;quot;jkl&amp;quot;;
                break;
            case &#39;6&#39; :
                return &amp;quot;mno&amp;quot;;
                break;
            case &#39;7&#39; :
                return &amp;quot;pqrs&amp;quot;;
                break;
            case &#39;8&#39; :
                return &amp;quot;tuv&amp;quot;;
                break;
            case &#39;9&#39; :
                return &amp;quot;wxyz&amp;quot;;
                break;
            default:
                return &amp;quot;&amp;quot;;
        }
    }
public:
    vector&amp;lt;string&amp;gt; res;
    vector&amp;lt;string&amp;gt; letterCombinations(string digits) {
        if(digits.size() == 0) return res;
        string s = &amp;quot;&amp;quot;;
        combination(s, digits);
        return res;
    }
    void combination(string c,string digits){
        if(digits.size() == 0){
            res.push_back(c);
            return;
        }
        string ch = phone(digits[0]);
        for(int i = 0; i &amp;lt; ch.size(); ++i){
            combination(c + ch[i],digits.substr(1));
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 19 - Remove Nth Node From End of List [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/19-remove-nth-node-from-end-of-list/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/19-remove-nth-node-from-end-of-list/</guid>
      <description>

&lt;h1 id=&#34;19-remove-nth-node-from-end-of-list&#34;&gt;19.Remove Nth Node From End of List&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/remove-nth-node-from-end-of-list/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a linked list, remove the n-th node from the end of list and return its head.&lt;/p&gt;

&lt;p&gt;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2.&lt;/p&gt;

&lt;p&gt;After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;Given n will always be valid.&lt;/p&gt;

&lt;h4 id=&#34;follow-up&#34;&gt;Follow up:&lt;/h4&gt;

&lt;p&gt;Could you do this in one pass?&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;h4 id=&#34;双指针&#34;&gt;双指针&lt;/h4&gt;

&lt;p&gt;右指针先走n次，左指针指向头结点，这时左指针一直指向当前右指针的倒数第n个节点，然后继续向后循环。&lt;br /&gt;
当右指针到达链表尾部时，左指针指向的下一个节点即为要删除的节点。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(1)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 96.74% of C++ online submissions for Remove Nth Node From End of List.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 49.56% of C++ online submissions for Remove Nth Node From End of List.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(n == 0){
            return head;
        }
        ListNode* res = new ListNode(0);  // 建立头结点，防止出现n=链表长度删不掉头结点的情况
        res-&amp;gt;next = head;
        ListNode* temp = res;
        for(int i = 1; i &amp;lt; n + 1; ++i){
            head = head-&amp;gt;next;           
        }
        while(NULL != head){
            head = head-&amp;gt;next;
            temp = temp-&amp;gt;next;
        }
        temp-&amp;gt;next = temp-&amp;gt;next-&amp;gt;next;
        return res-&amp;gt;next;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 20 - Valid Parentheses [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/20-valid-parentheses/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/20-valid-parentheses/</guid>
      <description>

&lt;h1 id=&#34;20-valid-parentheses&#34;&gt;20.Valid Parentheses&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/valid-parentheses/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a string containing just the characters &lt;code&gt;&#39;(&#39;&lt;/code&gt;, &lt;code&gt;&#39;)&#39;&lt;/code&gt;, &lt;code&gt;&#39;{&#39;&lt;/code&gt;, &lt;code&gt;&#39;}&#39;&lt;/code&gt;, &lt;code&gt;&#39;[&#39;&lt;/code&gt; and &lt;code&gt;&#39;]&#39;&lt;/code&gt;, determine if the input string is valid.&lt;/p&gt;

&lt;p&gt;An input string is valid if:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Open brackets must be closed by the same type of brackets.&lt;/li&gt;
&lt;li&gt;Open brackets must be closed in the correct order.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that an empty string is also considered valid.&lt;/p&gt;

&lt;p&gt;给定一个只包括 &lt;code&gt;&#39;(&#39;&lt;/code&gt;, &lt;code&gt;&#39;)&#39;&lt;/code&gt;, &lt;code&gt;&#39;{&#39;&lt;/code&gt;, &lt;code&gt;&#39;}&#39;&lt;/code&gt;, &lt;code&gt;&#39;[&#39;&lt;/code&gt; and &lt;code&gt;&#39;]&#39;&lt;/code&gt; 的字符串，判断字符串是否有效。&lt;/p&gt;

&lt;p&gt;有效字符串需满足：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;左括号必须用相同类型的右括号闭合。&lt;/li&gt;
&lt;li&gt;左括号必须以正确的顺序闭合。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意空字符串可被认为是有效字符串。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; &amp;ldquo;()&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; true&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;  &amp;ldquo;()[]{}&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; true&lt;/p&gt;

&lt;h4 id=&#34;example-3&#34;&gt;Example 3:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;  &amp;ldquo;(]&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; false&lt;/p&gt;

&lt;h4 id=&#34;example-4&#34;&gt;Example 4:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;  &amp;ldquo;([)]&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; false&lt;/p&gt;

&lt;h4 id=&#34;example-5&#34;&gt;Example 5:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;  &amp;ldquo;{[]}&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; true&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;使用栈。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(n)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 0 ms, faster than 100.00% of C++ online submissions for Valid Parentheses.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 50.17% of C++ online submissions for Valid Parentheses.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool isValid(string s) {
    if (s.size() == 0) return true;
    if (s.size() % 1) return false;
	stack&amp;lt;int&amp;gt; st;
	for (int i = 0; i &amp;lt; s.size(); ++i)
	{
		if (s[i] == &#39;(&#39; || s[i] == &#39;[&#39; || s[i] == &#39;{&#39;){
			st.push(s[i]);
		}
		else if (s[i] == &#39;)&#39;) {
			if (i == 0 || st.empty() || st.top() != &#39;(&#39;) return false;
			st.pop();
		}
		else if (s[i] == &#39;]&#39;) {
			if (i == 0 || st.empty() || st.top() != &#39;[&#39;) return false;
			st.pop();
		}
		else if(s[i] == &#39;}&#39;) {
			if (i == 0 || st.empty() || st.top() != &#39;{&#39;) return false;
			st.pop();
		}
	}
	return st.empty();
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>