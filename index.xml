<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cuckooemm&#39;s Blog on Cuckooemm&#39;s Blog</title>
    <link>https://cuckooemm.xyz/</link>
    <description>Recent content in Cuckooemm&#39;s Blog on Cuckooemm&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 06 Jun 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LeetCode - 23 - Merge k Sorted Lists [Hard]</title>
      <link>https://cuckooemm.xyz/2019/june/23-merge_k_sorted_lists/</link>
      <pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/23-merge_k_sorted_lists/</guid>
      <description>

&lt;h1 id=&#34;23-merge-k-sorted-lists&#34;&gt;23.Merge k Sorted Lists&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/merge-k-sorted-lists/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Hard&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.&lt;/p&gt;

&lt;p&gt;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;

&lt;h3 id=&#34;实例&#34;&gt;实例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;br /&gt;
[&lt;br /&gt;
  1-&amp;gt;4-&amp;gt;5,&lt;br /&gt;
  1-&amp;gt;3-&amp;gt;4,&lt;br /&gt;
  2-&amp;gt;6&lt;br /&gt;
]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;使用优先队列解决。
&lt;strong&gt;时间复杂度:O(n log k), 空间复杂度：O(k)。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 20 ms, faster than 99.55% of C++ online submissions for Merge k Sorted Lists.&lt;/li&gt;
&lt;li&gt;Memory Usage: 11.3 MB, less than 65.67% of C++ online submissions for Merge k Sorted Lists.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
private:
    struct cmp{
        bool operator()(ListNode* l,ListNode* r){
            return l-&amp;gt;val &amp;gt; r-&amp;gt;val;
        }
    };
public:
    ListNode* mergeKLists(vector&amp;lt;ListNode*&amp;gt;&amp;amp; lists) {
        if(lists.empty()) return NULL;
        priority_queue&amp;lt;ListNode*,vector&amp;lt;ListNode*&amp;gt;,cmp&amp;gt; p;
        ListNode* head = new ListNode(0);
        ListNode* cur = head;
        for(int i = 0; i &amp;lt; lists.size(); ++i){
            if(lists[i] != NULL){                  // 不为空加入优先队列
                p.push(lists[i]);
            }
        }
        while(!p.empty()){
            cur-&amp;gt;next = p.top();
            cur = cur-&amp;gt;next;
            p.pop();
            if(cur-&amp;gt;next != NULL){
                p.push(cur-&amp;gt;next);         
            }
        }
        return head-&amp;gt;next;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 17 - Letter Combinations of a Phone Number [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/17-letter_combinations_of_a_phone_number/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/17-letter_combinations_of_a_phone_number/</guid>
      <description>

&lt;h1 id=&#34;17-letter-combinations-of-a-phone-number&#34;&gt;17.Letter Combinations of a Phone Number&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/letter-combinations-of-a-phone-number/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a string containing digits from &lt;code&gt;2-9&lt;/code&gt; inclusive, return all possible letter combinations that the number could represent.&lt;/p&gt;

&lt;p&gt;A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.&lt;/p&gt;

&lt;p&gt;给定一个仅包含数字 &lt;code&gt;2-9&lt;/code&gt; 的字符串，返回所有它能表示的字母组合。&lt;/p&gt;

&lt;p&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; &amp;ldquo;23&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; [&amp;ldquo;ad&amp;rdquo;, &amp;ldquo;ae&amp;rdquo;, &amp;ldquo;af&amp;rdquo;, &amp;ldquo;bd&amp;rdquo;, &amp;ldquo;be&amp;rdquo;, &amp;ldquo;bf&amp;rdquo;, &amp;ldquo;cd&amp;rdquo;, &amp;ldquo;ce&amp;rdquo;, &amp;ldquo;cf&amp;rdquo;].&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;Although the above answer is in lexicographical order, your answer could be in any order you want.&lt;br /&gt;
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;递归实现。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(3&lt;sup&gt;n&lt;/sup&gt; * 4&lt;sup&gt;m&lt;/sup&gt;), 空间复杂度：O(3&lt;sup&gt;n&lt;/sup&gt; * 4&lt;sup&gt;m&lt;/sup&gt;)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 0 ms, faster than 100.00% of C++ online submissions for Letter Combinations of a Phone Number.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 50.00% of C++ online submissions for Letter Combinations of a Phone Number.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
private:
    string phone(char i){
        switch(i){
            case &#39;2&#39; :
                return &amp;quot;abc&amp;quot;;
                break;
            case &#39;3&#39; :
                return &amp;quot;def&amp;quot;;
                break;
            case &#39;4&#39; :
                return &amp;quot;ghi&amp;quot;;
                break;
            case &#39;5&#39; :
                return &amp;quot;jkl&amp;quot;;
                break;
            case &#39;6&#39; :
                return &amp;quot;mno&amp;quot;;
                break;
            case &#39;7&#39; :
                return &amp;quot;pqrs&amp;quot;;
                break;
            case &#39;8&#39; :
                return &amp;quot;tuv&amp;quot;;
                break;
            case &#39;9&#39; :
                return &amp;quot;wxyz&amp;quot;;
                break;
            default:
                return &amp;quot;&amp;quot;;
        }
    }
public:
    vector&amp;lt;string&amp;gt; res;
    vector&amp;lt;string&amp;gt; letterCombinations(string digits) {
        if(digits.size() == 0) return res;
        string s = &amp;quot;&amp;quot;;
        combination(s, digits);
        return res;
    }
    void combination(string c,string digits){
        if(digits.size() == 0){
            res.push_back(c);
            return;
        }
        string ch = phone(digits[0]);
        for(int i = 0; i &amp;lt; ch.size(); ++i){
            combination(c + ch[i],digits.substr(1));
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 19 - Remove Nth Node From End of List [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/19-remove_nth_node_from_end_of_list/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/19-remove_nth_node_from_end_of_list/</guid>
      <description>

&lt;h1 id=&#34;19-remove-nth-node-from-end-of-list&#34;&gt;19.Remove Nth Node From End of List&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/remove-nth-node-from-end-of-list/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a linked list, remove the n-th node from the end of list and return its head.&lt;/p&gt;

&lt;p&gt;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2.&lt;/p&gt;

&lt;p&gt;After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;Given n will always be valid.&lt;/p&gt;

&lt;h4 id=&#34;follow-up&#34;&gt;Follow up:&lt;/h4&gt;

&lt;p&gt;Could you do this in one pass?&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;h4 id=&#34;双指针&#34;&gt;双指针&lt;/h4&gt;

&lt;p&gt;右指针先走n次，左指针指向头结点，这时左指针一直指向当前右指针的倒数第n个节点，然后继续向后循环。&lt;br /&gt;
当右指针到达链表尾部时，左指针指向的下一个节点即为要删除的节点。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(1)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 96.74% of C++ online submissions for Remove Nth Node From End of List.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 49.56% of C++ online submissions for Remove Nth Node From End of List.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(n == 0){
            return head;
        }
        ListNode* res = new ListNode(0);  // 建立头结点，防止出现n=链表长度删不掉头结点的情况
        res-&amp;gt;next = head;
        ListNode* temp = res;
        for(int i = 1; i &amp;lt; n + 1; ++i){
            head = head-&amp;gt;next;           
        }
        while(NULL != head){
            head = head-&amp;gt;next;
            temp = temp-&amp;gt;next;
        }
        temp-&amp;gt;next = temp-&amp;gt;next-&amp;gt;next;
        return res-&amp;gt;next;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 20 - Valid Parentheses [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/20-valid_parentheses/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/20-valid_parentheses/</guid>
      <description>

&lt;h1 id=&#34;20-valid-parentheses&#34;&gt;20.Valid Parentheses&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/valid-parentheses/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a string containing just the characters &lt;code&gt;&#39;(&#39;&lt;/code&gt;, &lt;code&gt;&#39;)&#39;&lt;/code&gt;, &lt;code&gt;&#39;{&#39;&lt;/code&gt;, &lt;code&gt;&#39;}&#39;&lt;/code&gt;, &lt;code&gt;&#39;[&#39;&lt;/code&gt; and &lt;code&gt;&#39;]&#39;&lt;/code&gt;, determine if the input string is valid.&lt;/p&gt;

&lt;p&gt;An input string is valid if:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Open brackets must be closed by the same type of brackets.&lt;/li&gt;
&lt;li&gt;Open brackets must be closed in the correct order.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that an empty string is also considered valid.&lt;/p&gt;

&lt;p&gt;给定一个只包括 &lt;code&gt;&#39;(&#39;&lt;/code&gt;, &lt;code&gt;&#39;)&#39;&lt;/code&gt;, &lt;code&gt;&#39;{&#39;&lt;/code&gt;, &lt;code&gt;&#39;}&#39;&lt;/code&gt;, &lt;code&gt;&#39;[&#39;&lt;/code&gt; and &lt;code&gt;&#39;]&#39;&lt;/code&gt; 的字符串，判断字符串是否有效。&lt;/p&gt;

&lt;p&gt;有效字符串需满足：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;左括号必须用相同类型的右括号闭合。&lt;/li&gt;
&lt;li&gt;左括号必须以正确的顺序闭合。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意空字符串可被认为是有效字符串。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; &amp;ldquo;()&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; true&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;  &amp;ldquo;()[]{}&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; true&lt;/p&gt;

&lt;h4 id=&#34;example-3&#34;&gt;Example 3:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;  &amp;ldquo;(]&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; false&lt;/p&gt;

&lt;h4 id=&#34;example-4&#34;&gt;Example 4:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;  &amp;ldquo;([)]&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; false&lt;/p&gt;

&lt;h4 id=&#34;example-5&#34;&gt;Example 5:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;  &amp;ldquo;{[]}&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; true&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;使用栈。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(n)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 0 ms, faster than 100.00% of C++ online submissions for Valid Parentheses.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 50.17% of C++ online submissions for Valid Parentheses.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool isValid(string s) {
    if (s.size() == 0) return true;
    if (s.size() % 1) return false;
	stack&amp;lt;int&amp;gt; st;
	for (int i = 0; i &amp;lt; s.size(); ++i)
	{
		if (s[i] == &#39;(&#39; || s[i] == &#39;[&#39; || s[i] == &#39;{&#39;){
			st.push(s[i]);
		}
		else if (s[i] == &#39;)&#39;) {
			if (i == 0 || st.empty() || st.top() != &#39;(&#39;) return false;
			st.pop();
		}
		else if (s[i] == &#39;]&#39;) {
			if (i == 0 || st.empty() || st.top() != &#39;[&#39;) return false;
			st.pop();
		}
		else if(s[i] == &#39;}&#39;) {
			if (i == 0 || st.empty() || st.top() != &#39;{&#39;) return false;
			st.pop();
		}
	}
	return st.empty();
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 21 - Merge Two Sorted Lists [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/21-merge_two_sorted_lists/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/21-merge_two_sorted_lists/</guid>
      <description>

&lt;h1 id=&#34;21-merge-two-sorted-lists&#34;&gt;21.Merge Two Sorted Lists&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/merge-two-sorted-lists/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.&lt;/p&gt;

&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;比较大小然后修改指针。
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(1)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 0 ms, faster than 100.00% of C++ online submissions for Merge Two Sorted Lists.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9 MB, less than 60.71% of C++ online submissions for Merge Two Sorted Lists.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(NULL == l1) return l2;
        if(NULL == l2) return l1;
        ListNode* head = new ListNode(0);
        ListNode* res = head;
        while(l1 &amp;amp;&amp;amp; l2){
            if(l1-&amp;gt;val &amp;lt;= l2-&amp;gt;val){
                head-&amp;gt;next = l1;
                l1 = l1-&amp;gt;next;
            }else{
                head-&amp;gt;next = l2;
                l2 = l2-&amp;gt;next;
            }
            head = head-&amp;gt;next;
        }
        if(l1)
            head-&amp;gt;next = l1;
        else
            head-&amp;gt;next = l2;
        return res-&amp;gt;next;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 22 - Generate_Parentheses [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/22-generate_parentheses/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/22-generate_parentheses/</guid>
      <description>

&lt;h1 id=&#34;22-generate-parentheses&#34;&gt;22.Generate_Parentheses&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/generate-parentheses/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&lt;/p&gt;

&lt;p&gt;For example, given n = 3, a solution set is:&lt;/p&gt;

&lt;p&gt;给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;p&gt;例如，给出 n = 3，生成结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;[
  &amp;quot;((()))&amp;quot;,
  &amp;quot;(()())&amp;quot;,
  &amp;quot;(())()&amp;quot;,
  &amp;quot;()(())&amp;quot;,
  &amp;quot;()()()&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;使用递归。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 96.72% of C++ online submissions for Generate Parentheses.&lt;/li&gt;
&lt;li&gt;Memory Usage: 17.5 MB, less than 22.52% of C++ online submissions for Generate Parentheses.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
private:
    void generate(string s,int l,int r,int n){
        if(s.size() == n &amp;lt;&amp;lt; 1){
            res.push_back(s);
            return;
        }
        if(l &amp;lt; n)
            generate(s + &#39;(&#39;,l + 1,r,n);
        if(r &amp;lt; l)
            generate(s + &#39;)&#39;,l,r + 1,n);
    }
public:
    vector&amp;lt;string&amp;gt; res;
    vector&amp;lt;string&amp;gt; generateParenthesis(int n) {
        generate(&amp;quot;&amp;quot;,0,0,n);
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 11 - Container With Most Water [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/11-container_with_most_water/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/11-container_with_most_water/</guid>
      <description>

&lt;h1 id=&#34;11-container-with-most-water&#34;&gt;11.Container With Most Water&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/container-with-most-water/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given n non-negative integers a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;, &amp;hellip;, a&lt;sub&gt;n&lt;/sub&gt; , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.&lt;/p&gt;

&lt;p&gt;给定 n 个非负整数 a&lt;sub&gt;1&lt;/sub&gt;，a&lt;sub&gt;2&lt;/sub&gt;，&amp;hellip;，a&lt;sub&gt;n&lt;/sub&gt;，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;You may not slant the container and n is at least 2.&lt;br /&gt;
你不能倾斜容器，且 n 的值至少为 2。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,8,6,2,5,4,8,3,7]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 49&lt;/p&gt;

&lt;h3 id=&#34;思考&#34;&gt;思考&lt;/h3&gt;

&lt;h4 id=&#34;双指针法&#34;&gt;双指针法&lt;/h4&gt;

&lt;p&gt;定义指向头的左指针和指向尾的右指针，比较每次的值取最大。&lt;br /&gt;
因为横向只会减少，面积最大需要移动高小的值，所以选择左右指针值小的位置移动，左指针++，右指针&amp;ndash;。
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(1)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 16 ms, faster than 98.03% of C++ online submissions for Container With Most Water.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9.9 MB, less than 54.65% of C++ online submissions for Container With Most Water.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) {
        int maxArea = 0,l = 0,r = height.size() - 1;
        while(l &amp;lt; r){
            maxArea = max(maxArea,min(height[l],height[r]) * (r - l));  // 取最大值
            if(height[l] &amp;lt; height[r])
                ++l;
            else
                --r;
        }
        return maxArea;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 12 - Integer to Roman [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/12-integer_to_roman/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/12-integer_to_roman/</guid>
      <description>

&lt;h1 id=&#34;12-integer-to-roman&#34;&gt;12.Integer to Roman&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/integer-to-roman/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Roman numerals are represented by seven different symbols: &lt;strong&gt;I&lt;/strong&gt;, &lt;strong&gt;V&lt;/strong&gt;, &lt;strong&gt;X&lt;/strong&gt;, &lt;strong&gt;L&lt;/strong&gt;, &lt;strong&gt;C&lt;/strong&gt;, &lt;strong&gt;D&lt;/strong&gt; and &lt;strong&gt;M&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;罗马数字包含以下七种字符： &lt;strong&gt;I&lt;/strong&gt;， &lt;strong&gt;V&lt;/strong&gt;， &lt;strong&gt;X&lt;/strong&gt;， &lt;strong&gt;L&lt;/strong&gt;，&lt;strong&gt;C&lt;/strong&gt;，&lt;strong&gt;D&lt;/strong&gt; 和 &lt;strong&gt;M&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, two is written as &lt;strong&gt;II&lt;/strong&gt; in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, &lt;strong&gt;XII&lt;/strong&gt;, which is simply &lt;strong&gt;X&lt;/strong&gt; + &lt;strong&gt;II&lt;/strong&gt;. The number twenty seven is written as &lt;strong&gt;XXVII&lt;/strong&gt;, which is &lt;strong&gt;XX&lt;/strong&gt; + &lt;strong&gt;V&lt;/strong&gt; + &lt;strong&gt;II&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not &lt;strong&gt;IIII&lt;/strong&gt;. Instead, the number four is written as &lt;strong&gt;IV&lt;/strong&gt;. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as &lt;strong&gt;IX&lt;/strong&gt;. There are six instances where subtraction is used:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;I&lt;/strong&gt; can be placed before &lt;strong&gt;V&lt;/strong&gt; (5) and &lt;strong&gt;X&lt;/strong&gt; (10) to make 4 and 9.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;X&lt;/strong&gt; can be placed before &lt;strong&gt;L&lt;/strong&gt; (50) and &lt;strong&gt;C&lt;/strong&gt; (100) to make 40 and 90.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt; can be placed before &lt;strong&gt;D&lt;/strong&gt; (500) and &lt;strong&gt;M&lt;/strong&gt; (1000) to make 400 and 900.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.&lt;/p&gt;

&lt;p&gt;例如， 罗马数字 2 写做 &lt;strong&gt;II&lt;/strong&gt; ，即为两个并列的 1。12 写做 &lt;strong&gt;XII&lt;/strong&gt; ，即为 &lt;strong&gt;X&lt;/strong&gt; + &lt;strong&gt;II&lt;/strong&gt; 。 27 写做  &lt;strong&gt;XXVII&lt;/strong&gt;, 即为 &lt;strong&gt;XX&lt;/strong&gt; + &lt;strong&gt;V&lt;/strong&gt; + &lt;strong&gt;II&lt;/strong&gt; 。&lt;/p&gt;

&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 &lt;strong&gt;IIII&lt;/strong&gt;，而是 &lt;strong&gt;IV&lt;/strong&gt;。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 &lt;strong&gt;IX&lt;/strong&gt;。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;I&lt;/strong&gt; 可以放在 &lt;strong&gt;V&lt;/strong&gt; (5) 和 &lt;strong&gt;X&lt;/strong&gt; (10) 的左边，来表示 4 和 9。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;X&lt;/strong&gt; 可以放在 &lt;strong&gt;L&lt;/strong&gt; (50) 和 &lt;strong&gt;C&lt;/strong&gt; (100) 的左边，来表示 40 和 90。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt; 可以放在 &lt;strong&gt;D&lt;/strong&gt; (500) 和 &lt;strong&gt;M&lt;/strong&gt; (1000) 的左边，来表示 400 和 900。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 3&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;III&amp;rdquo;&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 4&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;IV&amp;rdquo;&lt;/p&gt;

&lt;h4 id=&#34;example-3&#34;&gt;Example 3:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 9&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;IX&amp;rdquo;&lt;/p&gt;

&lt;h4 id=&#34;example-4&#34;&gt;Example 4:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 58&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;LVIII&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; L = 50, V = 5, III = 3.&lt;/p&gt;

&lt;h4 id=&#34;example-5&#34;&gt;Example 5:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 1994&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;MCMXCIV&amp;rdquo;&lt;/p&gt;

&lt;h4 id=&#34;explanation-m-1000-cm-900-xc-90-and-iv-4&#34;&gt;Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.&lt;/h4&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;建立数字与罗马数字对应的两个数组。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(log&lt;sub&gt;10&lt;/sub&gt;(n)), 空间复杂度：O(1)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 98.84% of C++ online submissions for Integer to Roman.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.4 MB, less than 86.47% of C++ online submissions for Integer to Roman.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    string intToRoman(int num) {
        int border[] = {1000,900,500,400,100,90,50,40,10,9,5,4,1};
        string symbols[] = {&amp;quot;M&amp;quot;,&amp;quot;CM&amp;quot;,&amp;quot;D&amp;quot;,&amp;quot;CD&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;XC&amp;quot;,&amp;quot;L&amp;quot;,&amp;quot;XL&amp;quot;,&amp;quot;X&amp;quot;,&amp;quot;IX&amp;quot;,&amp;quot;V&amp;quot;,&amp;quot;IV&amp;quot;,&amp;quot;I&amp;quot;};
        string res = &amp;quot;&amp;quot;;
        for(int i = 0; i &amp;lt; 13; ++i){
            while(num &amp;gt;= border[i]){
                num -= border[i];
                res += symbols[i];
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 13 - Roman to Integer [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/13-roman_to_integer/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/13-roman_to_integer/</guid>
      <description>

&lt;h1 id=&#34;13-roman-to-integer&#34;&gt;13.Roman to Integer&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/roman-to-integer/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Roman numerals are represented by seven different symbols: &lt;strong&gt;I&lt;/strong&gt;, &lt;strong&gt;V&lt;/strong&gt;, &lt;strong&gt;X&lt;/strong&gt;, &lt;strong&gt;L&lt;/strong&gt;, &lt;strong&gt;C&lt;/strong&gt;, &lt;strong&gt;D&lt;/strong&gt; and &lt;strong&gt;M&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;罗马数字包含以下七种字符： &lt;strong&gt;I&lt;/strong&gt;， &lt;strong&gt;V&lt;/strong&gt;， &lt;strong&gt;X&lt;/strong&gt;， &lt;strong&gt;L&lt;/strong&gt;，&lt;strong&gt;C&lt;/strong&gt;，&lt;strong&gt;D&lt;/strong&gt; 和 &lt;strong&gt;M&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, two is written as &lt;strong&gt;II&lt;/strong&gt; in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, &lt;strong&gt;XII&lt;/strong&gt;, which is simply &lt;strong&gt;X&lt;/strong&gt; + &lt;strong&gt;II&lt;/strong&gt;. The number twenty seven is written as &lt;strong&gt;XXVII&lt;/strong&gt;, which is &lt;strong&gt;XX&lt;/strong&gt; + &lt;strong&gt;V&lt;/strong&gt; + &lt;strong&gt;II&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not &lt;strong&gt;IIII&lt;/strong&gt;. Instead, the number four is written as &lt;strong&gt;IV&lt;/strong&gt;. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as &lt;strong&gt;IX&lt;/strong&gt;. There are six instances where subtraction is used:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;I&lt;/strong&gt; can be placed before &lt;strong&gt;V&lt;/strong&gt; (5) and &lt;strong&gt;X&lt;/strong&gt; (10) to make 4 and 9.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;X&lt;/strong&gt; can be placed before &lt;strong&gt;L&lt;/strong&gt; (50) and &lt;strong&gt;C&lt;/strong&gt; (100) to make 40 and 90.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt; can be placed before &lt;strong&gt;D&lt;/strong&gt; (500) and &lt;strong&gt;M&lt;/strong&gt; (1000) to make 400 and 900.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.&lt;/p&gt;

&lt;p&gt;例如， 罗马数字 2 写做 &lt;strong&gt;II&lt;/strong&gt; ，即为两个并列的 1。12 写做 &lt;strong&gt;XII&lt;/strong&gt; ，即为 &lt;strong&gt;X&lt;/strong&gt; + &lt;strong&gt;II&lt;/strong&gt; 。 27 写做  &lt;strong&gt;XXVII&lt;/strong&gt;, 即为 &lt;strong&gt;XX&lt;/strong&gt; + &lt;strong&gt;V&lt;/strong&gt; + &lt;strong&gt;II&lt;/strong&gt; 。&lt;/p&gt;

&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 &lt;strong&gt;IIII&lt;/strong&gt;，而是 &lt;strong&gt;IV&lt;/strong&gt;。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 &lt;strong&gt;IX&lt;/strong&gt;。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;I&lt;/strong&gt; 可以放在 &lt;strong&gt;V&lt;/strong&gt; (5) 和 &lt;strong&gt;X&lt;/strong&gt; (10) 的左边，来表示 4 和 9。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;X&lt;/strong&gt; 可以放在 &lt;strong&gt;L&lt;/strong&gt; (50) 和 &lt;strong&gt;C&lt;/strong&gt; (100) 的左边，来表示 40 和 90。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt; 可以放在 &lt;strong&gt;D&lt;/strong&gt; (500) 和 &lt;strong&gt;M&lt;/strong&gt; (1000) 的左边，来表示 400 和 900。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 3&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;III&amp;rdquo;&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 4&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;IV&amp;rdquo;&lt;/p&gt;

&lt;h4 id=&#34;example-3&#34;&gt;Example 3:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 9&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;IX&amp;rdquo;&lt;/p&gt;

&lt;h4 id=&#34;example-4&#34;&gt;Example 4:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 58&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;LVIII&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; L = 50, V = 5, III = 3.&lt;/p&gt;

&lt;h4 id=&#34;example-5&#34;&gt;Example 5:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 1994&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;MCMXCIV&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; M = 1000, CM = 900, XC = 90 and IV = 4.&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;字符串表示的罗马数字，最左边一定是代表最大的数，如果遍历中出现了左边值大于右边值，说明出现了&lt;strong&gt;CM&lt;/strong&gt;、&lt;strong&gt;XC&lt;/strong&gt;、&lt;strong&gt;IV&lt;/strong&gt;这种情况。&lt;br /&gt;
减去小值加上大值，如：CM = -100 + 1000 = 900。&lt;br /&gt;
用&lt;code&gt;switch&lt;/code&gt;优化了原先用hashMap的效率，省略了hashMap所带来的计算消耗。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(1)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 98.36% of C++ online submissions for Roman to Integer.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.4 MB, less than 86.43% of C++ online submissions for Roman to Integer.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
private:
    int charToInt(char s){   // 替代 HashMap
        switch(s){
            case &#39;I&#39; :
                return 1;
                break;
            case &#39;V&#39; :
                return 5;
                break;
            case &#39;X&#39; :
                return 10;
                break;
            case &#39;L&#39; :
                return 50;
                break;
            case &#39;C&#39; :
                return 100;
                break;
            case &#39;D&#39; :
                return 500;
                break;
            case &#39;M&#39; :
                return 1000;
                break;
            default:
                return 0;
        }
    }
public:
    int romanToInt(string s) {
        int res = 0;
        for (int i = 0; i &amp;lt; s.size() - 1; ++i)
	    {
		    if (charToInt(s[i]) &amp;lt; charToInt(s[i+1]))
                res -= charToInt(s[i]);
		    else
                res += charToInt(s[i]);
	    }
	    res += charToInt(s[s.size() - 1]);   // 加上最后一个值
	    return res;
    }

};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 14 - Longest_Common_Prefix [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/14-longest_common_prefix/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/14-longest_common_prefix/</guid>
      <description>

&lt;h1 id=&#34;14-longest-common-prefix&#34;&gt;14.Longest_Common_Prefix&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-common-prefix/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Write a function to find the longest common prefix string amongst an array of strings.&lt;/p&gt;

&lt;p&gt;If there is no common prefix, return an empty string &amp;ldquo;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;/p&gt;

&lt;p&gt;如果不存在公共前缀，返回空字符串 &amp;ldquo;&amp;ldquo;。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [&amp;ldquo;flower&amp;rdquo;,&amp;ldquo;flow&amp;rdquo;,&amp;ldquo;flight&amp;rdquo;]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;fl&amp;rdquo;&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [&amp;ldquo;dog&amp;rdquo;,&amp;ldquo;racecar&amp;rdquo;,&amp;ldquo;car&amp;rdquo;]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; There is no common prefix among the input strings.&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;把第一个元素拷贝，然后依次比较之后的string。&lt;br /&gt;
遇到不同则裁剪字符串并跳去循环，开始下一个string。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(S), 空间复杂度：O(1)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 98.77% of C++ online submissions for Longest Common Prefix.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.8 MB, less than 85.87% of C++ online submissions for Longest Common Prefix.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) {
	if (strs.size() == 0) return &amp;quot;&amp;quot;;
    string result = strs[0];
	for (int i = 1; i &amp;lt; strs.size(); i++) {
		for (int j = 0; j &amp;lt; result.length(); j++) {
			if (result[j] != strs[i][j]) {
				result = result.substr(0, j);
				break;
			}
		}
	}
	return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 15 - 3Sum [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/15-3sum/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/15-3sum/</guid>
      <description>

&lt;h1 id=&#34;15-3sum&#34;&gt;15.3Sum&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/3sum/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given an array nums of n integers, are there elements a, b, c in &lt;code&gt;nums&lt;/code&gt; such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.&lt;/p&gt;

&lt;p&gt;给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;The solution set must not contain duplicate triplets.&lt;/p&gt;

&lt;p&gt;答案中不可以包含重复的三元组。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;首先对数组进行排序，选择一个数，然后用双指针法对比，如果和大于0，左移右指针，反之，右移左指针。
&lt;strong&gt;时间复杂度:O(n&lt;sup&gt;2&lt;/sup&gt;), 空间复杂度：O(1)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 92 ms, faster than 98.40% of C++ online submissions for 3Sum.&lt;/li&gt;
&lt;li&gt;Memory Usage: 14.8 MB, less than 76.43% of C++ online submissions for 3Sum.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; threeSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
        if(nums.size() &amp;lt; 3) return res;
        sort(nums.begin(),nums.end());                                  // 排序
        vector&amp;lt;int&amp;gt; t(3);
        int begin,end,sum;
 
        for(int i = 0; i &amp;lt; nums.size() - 2; ++i){
            if(nums[i] &amp;gt; 0) break;                                      // 如果值大于0，那么和无论如何不会等于0
            if(i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) continue;               // 排除重复
            begin = i + 1;
            end = nums.size() - 1;
            while(begin &amp;lt; end){
                sum = nums[i] + nums[begin] + nums[end];
                if(sum &amp;gt; 0) --end;
                else if(sum &amp;lt; 0) ++begin;
                else{
                    t[0] = nums[i];
                    t[1] = nums[begin];
                    t[2] = nums[end];
                    res.push_back(t);
                    while(begin &amp;lt; end &amp;amp;&amp;amp; nums[begin] == t[1]) ++begin;  //排除重复
                    while(begin &amp;lt; end &amp;amp;&amp;amp; nums[end] == t[2]) --end;      //排除重复
                }
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 16 - 3Sum Closest [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/16-3sum_closest/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/16-3sum_closest/</guid>
      <description>

&lt;h1 id=&#34;16-3sum-closest&#34;&gt;16.3Sum Closest&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/3sum-closest/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.&lt;/p&gt;

&lt;p&gt;给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;Given array nums = [-1, 2, 1, -4], and target = 1.&lt;/p&gt;

&lt;p&gt;The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;同样排序与双指针。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n&lt;sup&gt;2&lt;/sup&gt;), 空间复杂度：O(1)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 94.76% of C++ online submissions for 3Sum Closest.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.9 MB, less than 51.23% of C++ online submissions for 3Sum Closest.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;class Solution {
public:
    int threeSumClosest(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
        if(nums.size() &amp;lt; 3) return 0;
        int res = nums[0] + nums[1] + nums[2];                                     // 先计算一个近似值
        int begin,end,sum;
        sort(nums.begin(),nums.end());
        for(int i = 0; i &amp;lt; nums.size() -2; ++i){
            if(i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) continue;                          // 排除重复
            begin = i + 1;
            end = nums.size() - 1;
            while(begin &amp;lt; end){
                sum = nums[i] + nums[begin] + nums[end];
                if(abs(res - target) &amp;gt; abs(sum - target)){                         // 如果新值比旧值近似则更改
                    res = sum;
                }
                if(sum &amp;lt; target){
                    ++begin;
                    while(begin &amp;lt; end &amp;amp;&amp;amp; nums[begin] == nums[begin - 1]) ++begin;  // 排除重复
                }
                else if(sum &amp;gt; target) {
                    --end;
                    while(begin &amp;lt; end &amp;amp;&amp;amp; nums[end] == nums[end + 1]) --end;        // 排除重复
                }
                else{
                    return sum;                                                    // 相等直接返回
                }
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 9 - Palindrome Number [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/9-palindrome_number/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/9-palindrome_number/</guid>
      <description>

&lt;h1 id=&#34;9-palindrome-number&#34;&gt;9.Palindrome Number&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/palindrome-number/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.&lt;br /&gt;
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 121&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; true&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; -121&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; false&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.&lt;/p&gt;

&lt;h4 id=&#34;example-3&#34;&gt;Example 3:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 10&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; false&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; Reads 01 from right to left. Therefore it is not a palindrome.&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;首先把负值、除0外末尾为0的数字排除。&lt;br /&gt;
判断数字是否回文，我们可以翻转数字一半与前一半比较是否相等。&lt;br /&gt;
当&lt;strong&gt;x&lt;/strong&gt;小于新的数时则完成了对半。&lt;br /&gt;
数字个数有奇有偶，如果为偶，则新数等于x,如果为奇，则中间数字应在新数的个位上，新数除以10则长度与x相等，判断数是否相等。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(log&lt;sub&gt;10&lt;/sub&gt;(n)), 空间复杂度：O(1)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 12 ms, faster than 93.35% of C++ online submissions for Palindrome Number.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.1 MB, less than 71.09% of C++ online submissions for Palindrome Number.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool isPalindrome(int x) {
        if (x &amp;lt; 0 || x % 10 == 0 &amp;amp;&amp;amp; x != 0) return false;   // 负值、除0外末尾为0的数字返回false
        int res = 0;
        while(x &amp;gt; res){
            res = res * 10 + x % 10;                        // 反转数字
            x /= 10;
        }
        return x == res || res / 10 == x;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 6 - ZigZag Conversion [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/6-zigzag_conversion/</link>
      <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/6-zigzag_conversion/</guid>
      <description>

&lt;h1 id=&#34;6-zigzag-conversion&#34;&gt;6.ZigZag Conversion&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/zigzag-conversion/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;The string &lt;code&gt;&amp;quot;PAYPALISHIRING&amp;quot;&lt;/code&gt; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)&lt;br /&gt;
使字符串以给定行数上进行Z字形书写，像下面这样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;P   A   H   N
A P L S I I G
Y   I   R
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then read line by line: &lt;code&gt;&amp;quot;PAHNAPLSIIGYIR&amp;quot;&lt;/code&gt;&lt;br /&gt;
然后一行一行的读。&lt;br /&gt;
Write the code that will take a string and make this conversion given a number of rows:&lt;br /&gt;
编写代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;string convert(string s, int numRows);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; s = &amp;ldquo;PAYPALISHIRING&amp;rdquo;, numRows = 3&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;PAHNAPLSIIGYIR&amp;rdquo;&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; s = &amp;ldquo;PAYPALISHIRING&amp;rdquo;, numRows = 4&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;PINALSIGYAHRPI&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;P     I    N
A   L S  I G
Y A   H R
P     I
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;就是计算字符串下标。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;行&lt;code&gt;0&lt;/code&gt;中的字符位于索引&lt;code&gt;k&lt;/code&gt;(2 * numRows - 2)处。&lt;/li&gt;
&lt;li&gt;行&lt;code&gt;numRows-1&lt;/code&gt;中的字符位于索引&lt;code&gt;k&lt;/code&gt;(2 * numRows − 2) + numRows − 1处;&lt;/li&gt;
&lt;li&gt;内部的行&lt;code&gt;i&lt;/code&gt;中的字符位于索引&lt;code&gt;k&lt;/code&gt;(2 * numRows − 2) + i 以及 (2 * numRows − 2) − i处;&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(n)&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 12 ms, faster than 94.01% of C++ online submissions for ZigZag Conversion.&lt;/li&gt;
&lt;li&gt;Memory Usage: 10.2 MB, less than 85.33% of C++ online submissions for ZigZag Conversion.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    string convert(string s, int numRows) {
        if(s.size() == 0 | numRows == 1){
            return s;
        }
        string res = &amp;quot;&amp;quot;;
        int n = s.size();
        int size = (numRows &amp;lt;&amp;lt; 1) - 2;
        int temp = 0;
        for(int i = 0; i &amp;lt; numRows; ++i){
            for(int j = i; j &amp;lt; n; j += size){
                res += s[j];
                temp = j + size - (i &amp;lt;&amp;lt; 1);
                if(i != 0 &amp;amp;&amp;amp; i != numRows - 1 &amp;amp;&amp;amp; temp &amp;lt; n)
                    res += s[temp];
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 7 - Reverse Integer [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/7-reverse_integer/</link>
      <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/7-reverse_integer/</guid>
      <description>

&lt;h1 id=&#34;7-reverse-integer&#34;&gt;7.Reverse Integer&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/reverse-integer/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a 32-bit signed integer, reverse digits of an integer.&lt;/p&gt;

&lt;p&gt;给定一个32位有符号整数，对整数的每位数字进行反转。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 123&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 321&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; -123&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; -321&lt;/p&gt;

&lt;h4 id=&#34;example-3&#34;&gt;Example 3:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 120&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 21&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2&lt;sup&gt;31&lt;/sup&gt;,  2&lt;sup&gt;31&lt;/sup&gt; − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.&lt;/p&gt;

&lt;p&gt;假设我们的环境只能存储32位范围内的带符号整数：[−2&lt;sup&gt;31&lt;/sup&gt;,  2&lt;sup&gt;31&lt;/sup&gt; − 1]。整数反转溢出时返回0。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;主要是溢出判断&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(log&lt;sub&gt;10&lt;/sub&gt;(x)), 空间复杂度：O(1)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 0 ms, faster than 100.00% of C++ online submissions for Reverse Integer.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.5 MB, less than 54.65% of C++ online submissions for Reverse Integer.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int reverse(int x) {
        int rev = 0;
        while (x != 0) {
            int pop = x % 10;
            x /= 10;
            if (rev &amp;gt; INT_MAX / 10 || (rev == INT_MAX / 10 &amp;amp;&amp;amp; pop &amp;gt; 7)) return 0;
            if (rev &amp;lt; INT_MIN / 10 || (rev == INT_MIN / 10 &amp;amp;&amp;amp; pop &amp;lt; -8)) return 0;
            rev = rev * 10 + pop;
        }
        return rev;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>