<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cuckooemm&#39;s Blog on Cuckooemm&#39;s Blog</title>
    <link>https://cuckooemm.xyz/</link>
    <description>Recent content in Cuckooemm&#39;s Blog on Cuckooemm&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 11 Jul 2019 13:09:57 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Leetcode - 41 - First Missing Positive [Hard]</title>
      <link>https://cuckooemm.xyz/2019/july/41-first-missing-positive/</link>
      <pubDate>Thu, 11 Jul 2019 13:09:57 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/41-first-missing-positive/</guid>
      <description>

&lt;h1 id=&#34;41-first-missing-positive&#34;&gt;41.First Missing Positive&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/first-missing-positive/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Hard&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given an unsorted integer array, find the smallest missing positive integer.&lt;/p&gt;

&lt;p&gt;给定一个未排序的整数数组，找出其中没有出现的最小的正整数。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,2,0]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 3&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [3,4,-1,1]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 2&lt;/p&gt;

&lt;h4 id=&#34;example-3&#34;&gt;Example 3:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [7,8,9,11,12]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 1&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;Your algorithm should run in O(n) time and uses constant extra space.&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;利用桶排序的思路。&lt;br /&gt;
负数与大于数组长度的数字不考虑。&lt;br /&gt;
用数组中的数当作索引，存放在nums[i] - 1 的索引位置。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 0 ms, faster than 100.00% of C++ online submissions for First Missing Positive.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 30.44% of C++ online submissions for First Missing Positive.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int firstMissingPositive(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        if(nums.size() &amp;lt; 1)
            return 1;
        for(int i = 0; i &amp;lt; nums.size(); ++i){
            while(nums[i] &amp;gt; 0 &amp;amp;&amp;amp; nums[i] &amp;lt;= nums.size() &amp;amp;&amp;amp; nums[nums[i] - 1] != nums[i]){
                swap(nums[i],nums[nums[i] - 1]);
            }
        }
        for(int i = 0; i &amp;lt; nums.size(); ++i){
            if(nums[i] != i + 1){
                return i + 1;
            }
        }
        return nums.size() + 1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 40 - Combination Sum II [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/40-combination-sum-ii/</link>
      <pubDate>Tue, 09 Jul 2019 22:22:41 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/40-combination-sum-ii/</guid>
      <description>

&lt;h1 id=&#34;40-combination-sum-ii&#34;&gt;40.Combination Sum II&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum-ii/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.&lt;/p&gt;

&lt;p&gt;Each number in candidates may only be used once in the combination.&lt;/p&gt;

&lt;p&gt;给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。&lt;/p&gt;

&lt;p&gt;candidates 中的每个数字在每个组合中只能使用一次。&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The solution set must not contain duplicate combinations.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所有数字（包括目标数）都是正整数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解集不能包含重复的组合。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; candidates = [10,1,2,7,6,1,5], target = 8,&lt;br /&gt;
A solution set is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; candidates = [2,5,2,1,2], target = 5,&lt;br /&gt;
A solution set is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[
  [1,2,2],
  [5]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;与Combination Sum 方法一致，因不包含重复项所以递归时从当前push数组下标的下一个位置开始。排序解决重复项问题。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 99.44% of C++ online submissions for Combination Sum II.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9.1 MB, less than 59.13% of C++ online submissions for Combination Sum II.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
private:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    vector&amp;lt;int&amp;gt; tmp;
    void dfs(vector&amp;lt;int&amp;gt;&amp;amp; candidates,int target,int index){
        if(target == 0)
            return res.push_back(tmp);
        for(int i = index; i &amp;lt; candidates.size(); ++i){
            if(candidates[i] &amp;gt; target) break;
            if(index != i &amp;amp;&amp;amp; candidates[i] == candidates[i - 1])
                continue;
            tmp.push_back(candidates[i]);
            dfs(candidates,target - candidates[i],i + 1);            // 数字只能选取一次，从当前索引位置+1
            tmp.pop_back();
        }
    }
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum2(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) {
        sort(candidates.begin(),candidates.end());
        dfs(candidates,target,0);
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 39 - Combination Sum [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/39-combination-sum/</link>
      <pubDate>Tue, 09 Jul 2019 16:25:26 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/39-combination-sum/</guid>
      <description>

&lt;h1 id=&#34;39-combination-sum&#34;&gt;39.Combination Sum&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.&lt;/p&gt;

&lt;p&gt;The same repeated number may be chosen from candidates unlimited number of times.&lt;/p&gt;

&lt;p&gt;给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。&lt;/p&gt;

&lt;p&gt;candidates 中的数字可以无限制重复被选取。&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The solution set must not contain duplicate combinations.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所有数字（包括 target）都是正整数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解集不能包含重复的组合。 &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; candidates = [2,3,6,7], target = 7,&lt;br /&gt;
A solution set is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[  
  [7],  
  [2,2,3]  
]  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; candidates = [2,3,5], target = 8,&lt;br /&gt;
A solution set is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[  
  [2,2,2,2],  
  [2,3,3],  
  [3,5]  
]  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;递归回溯。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 98.70% of C++ online submissions for Combination Sum.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9.7 MB, less than 58.59% of C++ online submissions for Combination Sum.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
private:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    vector&amp;lt;int&amp;gt; temp;
    void dfs(vector&amp;lt;int&amp;gt;&amp;amp; candidates,int target,int index){
        if(target == 0)
            return res.push_back(temp);
        for(; index &amp;lt; candidates.size(); ++index){
            if(candidates[index] &amp;gt; target) continue;
            temp.push_back(candidates[index]);
            dfs(candidates,target - candidates[index],index);        // 数字可被无限次选取，沿用当前位置索引
            temp.pop_back();
        }
    }
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) {
        dfs(candidates,target,0);
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 38 - Count and Say [Easy]</title>
      <link>https://cuckooemm.xyz/2019/july/38-count-and-say/</link>
      <pubDate>Mon, 08 Jul 2019 17:32:57 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/38-count-and-say/</guid>
      <description>

&lt;h1 id=&#34;38-count-and-say&#34;&gt;38.Count and Say&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/count-and-say/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;The count-and-say sequence is the sequence of integers with the first five terms as following:&lt;/p&gt;

&lt;p&gt;报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;     1
     11
     21
     1211
     111221
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;1 is read off as &amp;ldquo;one 1&amp;rdquo; or 11.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;11 is read off as &amp;ldquo;two 1s&amp;rdquo; or 21.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;21 is read off as &amp;ldquo;one 2, then one 1&amp;rdquo; or 1211.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;1 被读作  &amp;rdquo;one 1&amp;rdquo;  (&amp;ldquo;一个一&amp;rdquo;) , 即 11。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;11 被读作 &amp;rdquo;two 1s&amp;rdquo; (&amp;ldquo;两个一&amp;rdquo;）, 即 21。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;21 被读作 &amp;rdquo;one 2&amp;rdquo;,  &amp;rdquo;one 1&amp;rdquo; （&amp;rdquo;一个二&amp;rdquo; ,  &amp;rdquo;一个一&amp;rdquo;) , 即 1211。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.&lt;/p&gt;

&lt;p&gt;给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。&lt;/p&gt;

&lt;h4 id=&#34;note-each-term-of-the-sequence-of-integers-will-be-represented-as-a-string&#34;&gt;Note: Each term of the sequence of integers will be represented as a string.&lt;/h4&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 1&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;1&amp;rdquo;&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 4&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;1211&amp;rdquo;&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;使用循环依次计算后项。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 0 ms, faster than 100.00% of C++ online submissions for Count and Say.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 80.15% of C++ online submissions for Count and Say.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    string countAndSay(int n) {
        string curRes = &amp;quot;1&amp;quot;;
        string res = &amp;quot;&amp;quot;;
        int curIndex = 2,count = 1;
        while(curIndex &amp;lt;= n){
            res = &amp;quot;&amp;quot;;
            for(int i = 0; i &amp;lt; curRes.size(); ++i){
                if(i+1 &amp;lt; curRes.size() &amp;amp;&amp;amp; curRes[i] == curRes[i + 1]){
                    ++count;
                }else{
                    res.push_back(count + 48);
                    res.push_back(curRes[i]);
                    count = 1;
                }
            }
            curRes = res;
            ++curIndex;
        }
        return curRes;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 35 - Search Insert Position [Easy]</title>
      <link>https://cuckooemm.xyz/2019/july/35-search-insert-position/</link>
      <pubDate>Sun, 07 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/35-search-insert-position/</guid>
      <description>

&lt;h1 id=&#34;35-search-insert-position&#34;&gt;35.Search Insert Position&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-insert-position/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.&lt;/p&gt;

&lt;p&gt;You may assume no duplicates in the array.&lt;/p&gt;

&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;

&lt;p&gt;你可以假设数组中无重复元素。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,3,5,6], 5&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 2&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,3,5,6], 2&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 1&lt;/p&gt;

&lt;h4 id=&#34;example-3&#34;&gt;Example 3:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,3,5,6], 7&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 4&lt;/p&gt;

&lt;h4 id=&#34;example-4&#34;&gt;Example 4:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,3,5,6], 0&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 0&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;二分法。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 74.90% of C++ online submissions for Search Insert Position.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.9 MB, less than 59.90% of C++ online submissions for Search Insert Position.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
        int mid = 0, l = 0, r = nums.size() - 1;
        while(l &amp;lt;= r){
            mid = (r - l &amp;gt;&amp;gt; 1) + l;
            if(nums[mid] == target)
                return mid;
            else if(nums[mid] &amp;gt; target)
                r = mid - 1;
            else
                l = mid + 1;
        }
        return l;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 36 - Valid Sudoku [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/36-valid-sudoku/</link>
      <pubDate>Sun, 07 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/36-valid-sudoku/</guid>
      <description>

&lt;h1 id=&#34;36-valid-sudoku&#34;&gt;36.Valid Sudoku&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/valid-sudoku/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:&lt;/p&gt;

&lt;p&gt;1.Each row must contain the digits 1-9 without repetition.&lt;br /&gt;
2.Each column must contain the digits 1-9 without repetition.&lt;br /&gt;
3.Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.&lt;/p&gt;

&lt;p&gt;The Sudoku board could be partially filled, where empty cells are filled with the character &amp;lsquo;.&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。&lt;/p&gt;

&lt;p&gt;数字 1-9 在每一行只能出现一次。&lt;br /&gt;
数字 1-9 在每一列只能出现一次。&lt;br /&gt;
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。&lt;/p&gt;

&lt;p&gt;数独部分空格内已填入了数字，空白格用 &amp;rsquo;.&amp;lsquo; 表示。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[
  [&amp;quot;5&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;],
  [&amp;quot;4&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;],
  [&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;5&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;9&amp;quot;]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt; true&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[
  [&amp;quot;8&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;],
  [&amp;quot;4&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;],
  [&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;5&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;9&amp;quot;]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt; false
&lt;strong&gt;Explanation:&lt;/strong&gt; Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8&amp;rsquo;s in the top left 3x3 sub-box, it is invalid.&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;A Sudoku board (partially filled) could be valid but is not necessarily solvable.&lt;br /&gt;
Only the filled cells need to be validated according to the mentioned rules.&lt;br /&gt;
The given board contain only digits 1-9 and the character &amp;lsquo;.&amp;rsquo;.&lt;br /&gt;
The given board size is always 9x9.&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;使用数组分别保存每行每列出现过的数字。&lt;br /&gt;
期中，box_index = row / 3 * 3 + columns / 3。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 20 ms, faster than 43.73% of C++ online submissions for Valid Sudoku.&lt;/li&gt;
&lt;li&gt;Memory Usage: 10.8 MB, less than 28.58% of C++ online submissions for Valid Sudoku.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool isValidSudoku(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) {
        vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; r(9,vector&amp;lt;bool&amp;gt;(9,false));
        vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; c(9,vector&amp;lt;bool&amp;gt;(9,false));
        vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; b(9,vector&amp;lt;bool&amp;gt;(9,false));
        int index = 0,b_index = 0;
        for(int i = 0; i &amp;lt; 9; ++i)
            for(int j = 0; j &amp;lt; 9; ++j){
                if(board[i][j] != &#39;.&#39;){
                    index = board[i][j] - 49;
                    b_index = i / 3 * 3 + j / 3;
                    if(r[i][index] || c[j][index] || b[b_index][index]){
                        return false;
                    }else{
                        r[i][index] = true;
                        c[j][index] = true;
                        b[b_index][index] = true;
                    }
                }
            }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 33 - Search in Rotated Sorted Array [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/33-search-in-rotated-sorted-array/</link>
      <pubDate>Sat, 06 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/33-search-in-rotated-sorted-array/</guid>
      <description>

&lt;h1 id=&#34;33-search-in-rotated-sorted-array&#34;&gt;33.Search in Rotated Sorted Array&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-in-rotated-sorted-array/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;/p&gt;

&lt;p&gt;(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).&lt;/p&gt;

&lt;p&gt;You are given a target value to search. If found in the array return its index, otherwise return -1.&lt;/p&gt;

&lt;p&gt;You may assume no duplicate exists in the array.&lt;/p&gt;

&lt;p&gt;Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).&lt;/p&gt;

&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;

&lt;p&gt;( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。&lt;/p&gt;

&lt;p&gt;搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。&lt;/p&gt;

&lt;p&gt;你可以假设数组中不存在重复的元素。&lt;/p&gt;

&lt;p&gt;你的算法时间复杂度必须是 O(log n) 级别。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; nums = [4,5,6,7,0,1,2], target = 0&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 4&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; nums = [4,5,6,7,0,1,2], target = 3&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; -1&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;题目要求 O(log n) 级别复杂度，所以采用&lt;strong&gt;二分法&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 0 ms, faster than 100.00% of C++ online submissions for Search in Rotated Sorted Array.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.5 MB, less than 99.60% of C++ online submissions for Search in Rotated Sorted Array.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
        int l = 0,r = nums.size() - 1;
        int mid = 0;
        while(l &amp;lt;= r){
            mid = (r - l &amp;gt;&amp;gt; 1) + l;                             // 防止加法溢出
            if(nums[mid] == target) return mid; 
            if(nums[mid] &amp;gt;= nums[l]){                           // 说明mid左边有序
                if(nums[mid] &amp;gt; target &amp;amp;&amp;amp; nums[l] &amp;lt;= target)     // 查看mid是否在左区间
                    r = mid - 1;
                else
                    l = mid + 1;
            }else{                                              // 等同 mid &amp;lt; r
                if(nums[mid] &amp;lt; target &amp;amp;&amp;amp; nums[r] &amp;gt;= target)     // 查看mid是否在右区间
                    l = mid + 1;
                else
                    r = mid - 1;
            }
        }
        return -1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 34 - Find First and Last Position of Element in Sorted Array [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/34-find-first-and-last-position-of-element-in-sorted-array/</link>
      <pubDate>Sat, 06 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/34-find-first-and-last-position-of-element-in-sorted-array/</guid>
      <description>

&lt;h1 id=&#34;34-find-first-and-last-position-of-element-in-sorted-array&#34;&gt;34.Find First and Last Position of Element in Sorted Array&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.&lt;/p&gt;

&lt;p&gt;Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).&lt;/p&gt;

&lt;p&gt;If the target is not found in the array, return [-1, -1].&lt;/p&gt;

&lt;p&gt;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。&lt;/p&gt;

&lt;p&gt;你的算法时间复杂度必须是 O(log n) 级别。&lt;/p&gt;

&lt;p&gt;如果数组中不存在目标值，返回 [-1, -1]。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; nums = [5,7,7,8,8,10], target = 8&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; [3,4]&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; nums = [5,7,7,8,8,10], target = 6&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; [-1,-1]&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;题目要求 O(log n) 级别复杂度，所以采用&lt;strong&gt;二分法&lt;/strong&gt;。&lt;br /&gt;
先找到target的索引，然后以此为中心，在左半区找最小索引，右半区找最大索引。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 90.94% of C++ online submissions for Find First and Last Position of Element in Sorted Array.&lt;/li&gt;
&lt;li&gt;Memory Usage: 10.2 MB, less than 76.14% of C++ online submissions for Find First and Last Position of Element in Sorted Array.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; searchRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
        int mid = 0, l = 0, r = nums.size() - 1;
        int lm = l, rm = r;
        vector&amp;lt;int&amp;gt; res(2,-1);
        while(l &amp;lt;= r){
            mid = (r - l &amp;gt;&amp;gt; 1) + l;
            if(nums[mid] == target){
                lm = mid;
                rm = mid;
                while(l &amp;lt;= lm){                 // 在[l,lm]中找最小索引
                    mid = (lm - l &amp;gt;&amp;gt; 1) + l;
                    if(nums[mid] == target){
                        lm = mid - 1;
                        res[0] = mid;
                    }else
                        l = mid + 1;
                }
                while(rm &amp;lt;= r){                 // 在[rm,r]中找最大索引
                    mid = (r - rm &amp;gt;&amp;gt; 1) + rm;
                    if(nums[mid] == target){
                        rm = mid + 1;
                        res[1] = mid;
                    }else
                        r = mid - 1;
                }
                break;                          // 跳出循环
            }else if(target &amp;gt; nums[mid]){
                l = mid + 1;
            }else
                r = mid - 1;
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang 代理</title>
      <link>https://cuckooemm.xyz/2019/july/golang-%E4%BB%A3%E7%90%86/</link>
      <pubDate>Fri, 05 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/golang-%E4%BB%A3%E7%90%86/</guid>
      <description>

&lt;h1 id=&#34;解决golang依赖网络问题&#34;&gt;解决golang依赖网络问题&lt;/h1&gt;

&lt;p&gt;添加环境变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;key: GOPROXY     value: https://goproxy.io
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 29 - Divide Two Integers [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/29-divide-two-integers/</link>
      <pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/29-divide-two-integers/</guid>
      <description>

&lt;h1 id=&#34;29-divide-two-integers&#34;&gt;29.Divide Two Integers&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/divide-two-integers/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.&lt;/p&gt;

&lt;p&gt;Return the quotient after dividing dividend by divisor.&lt;/p&gt;

&lt;p&gt;The integer division should truncate toward zero.&lt;/p&gt;

&lt;p&gt;给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。&lt;/p&gt;

&lt;p&gt;返回被除数 dividend 除以除数 divisor 得到的商。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; dividend = 10, divisor = 3&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 3&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; dividend = 7, divisor = -3&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; -2&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;Both dividend and divisor will be 32-bit signed integers.&lt;br /&gt;
The divisor will never be 0.&lt;br /&gt;
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2&lt;sup&gt;31&lt;/sup&gt;,  2&lt;sup&gt;31&lt;/sup&gt; − 1].
For the purpose of this problem, assume that your function returns 2&lt;sup&gt;31&lt;/sup&gt; − 1 when the division result overflows.&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;余数可以用被除数减去除数求得。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;每次减完除数翻倍，倍数记录翻的倍数。如果当前除数大于被除数，则缩小。位移操作实现。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;异或判断符号。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(log(n)), 空间复杂度：O(1)。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 93.13% of C++ online submissions for Divide Two Integers.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.3 MB, less than 53.98% of C++ online submissions for Divide Two Integers.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int divide(int dividend, int divisor) {
        if(dividend == -2147483648 &amp;amp;&amp;amp; divisor == -1) return INT_MAX;   // 溢出的输入直接返回
        if(divisor == 1) return dividend;                              // 除数为1直接返回
        long long dd = abs((long long)dividend);                       // -2147483648 的绝对值大于int类型的最大整数
        long long dr = abs((long long)divisor);
        int res = 0;                                                   // 保存结果
        int times = 1;                                                 // 倍数
        while(dd &amp;gt;= dr || times &amp;gt; 1){
            if(dd &amp;gt;= dr){
                dd -= dr;
                res += times;
                dr = dr &amp;lt;&amp;lt; 1;                                          // 除数扩大一倍
                times = times &amp;lt;&amp;lt; 1;                                    // 倍数也扩大一倍
            }else{
                dr = dr &amp;gt;&amp;gt; 1;                                          // 除数缩小一倍
                times = times &amp;gt;&amp;gt; 1;                                    // 倍数缩小一倍
            }
        }
        return (dividend ^ divisor) &amp;gt;= 0 ? res : -res;                 // 异或判断符号是否不等
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 31 - Next Permutation [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/31-next-permutation/</link>
      <pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/31-next-permutation/</guid>
      <description>

&lt;h1 id=&#34;31-next-permutation&#34;&gt;31.Next Permutation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/next-permutation/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.&lt;/p&gt;

&lt;p&gt;If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).&lt;/p&gt;

&lt;p&gt;The replacement must be in-place and use only constant extra memory.&lt;/p&gt;

&lt;p&gt;Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.&lt;/p&gt;

&lt;p&gt;实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。&lt;/p&gt;

&lt;p&gt;如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。&lt;/p&gt;

&lt;p&gt;必须原地修改，只允许使用额外常数空间。&lt;/p&gt;

&lt;p&gt;以下是一些例子，输入位于左侧列，其相应输出位于右侧列。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;p&gt;1,2,3 → 1,3,2&lt;br /&gt;
3,2,1 → 1,2,3&lt;br /&gt;
1,1,5 → 1,5,1&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;从右往左遍历，如果i小于i+1的值则退出循环。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在i到end的区间内寻找最小的大于当前i位置值的数交换。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;反转i之后的数字。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 92.20% of C++ online submissions for Next Permutation.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 55.56% of C++ online submissions for Next Permutation.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    void nextPermutation(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int i = nums.size() - 2;
        while(i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[i + 1]){
            --i;
        }
        if(i &amp;gt;= 0){
            int j = nums.size() - 1;
            while(j &amp;gt; i &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[j]){
                --j;
            }
            swap(nums[i],nums[j]);
        }
        reverse(nums,i + 1);
    }
    void reverse(vector&amp;lt;int&amp;gt;&amp;amp; nums,int start){
        int r = nums.size() - 1;
        while(start &amp;lt; r){
            swap(nums[start],nums[r]);
            ++start;
            --r;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 27 - Remove Element [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/27-remove-element/</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/27-remove-element/</guid>
      <description>

&lt;h1 id=&#34;27-remove-element&#34;&gt;27.Remove Element&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/remove-element/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given an array nums and a value val, remove all instances of that value in-place and return the new length.&lt;/p&gt;

&lt;p&gt;Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.&lt;/p&gt;

&lt;p&gt;The order of elements can be changed. It doesn&amp;rsquo;t matter what you leave beyond the new length.&lt;/p&gt;

&lt;p&gt;给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。&lt;/p&gt;

&lt;p&gt;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;

&lt;p&gt;元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;Given nums = [3,2,2,3], val = 3,&lt;/p&gt;

&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 2.&lt;/p&gt;

&lt;p&gt;It doesn&amp;rsquo;t matter what you leave beyond the returned length.&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;Given nums = [0,1,2,2,3,0,4,2], val = 2,&lt;/p&gt;

&lt;p&gt;Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.&lt;/p&gt;

&lt;p&gt;Note that the order of those five elements can be arbitrary.&lt;/p&gt;

&lt;p&gt;It doesn&amp;rsquo;t matter what values are set beyond the returned length.&lt;/p&gt;

&lt;h4 id=&#34;clarification&#34;&gt;Clarification:&lt;/h4&gt;

&lt;p&gt;Confused why the returned value is an integer but your answer is an array?&lt;/p&gt;

&lt;p&gt;Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.&lt;/p&gt;

&lt;p&gt;Internally you can think of this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// nums is passed in by reference. (i.e., without making a copy)
int len = removeElement(nums, val);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i &amp;lt; len; i++) {
    print(nums[i]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;遍历nums,如果数组内值与目标值不等，且当前已经出现过目标值，则把i位置的值赋给l位置。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(1)。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 89.95% of C++ online submissions for Remove Element.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 54.44% of C++ online submissions for Remove Element.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int removeElement(vector&amp;lt;int&amp;gt;&amp;amp; nums, int val) {
        int l = 0;
        for(int i = 0; i &amp;lt; nums.size(); ++i){
            if(nums[i] != val){
                if(i != l){
                    nums[l++] = nums[i];
                }else{
                    ++l;
                }
            }
        }
        return l;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 28 - Implment StrStr() [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/28-implment-strstr/</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/28-implment-strstr/</guid>
      <description>

&lt;h1 id=&#34;28-implment-strstr&#34;&gt;28.Implment StrStr()&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/implement-strstr/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Implement strStr().&lt;/p&gt;

&lt;p&gt;Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack&lt;/p&gt;

&lt;p&gt;实现 strStr() 函数。&lt;/p&gt;

&lt;p&gt;给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; haystack = &amp;ldquo;hello&amp;rdquo;, needle = &amp;ldquo;ll&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 2&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; haystack = &amp;ldquo;aaaaa&amp;rdquo;, needle = &amp;ldquo;bba&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; -1&lt;/p&gt;

&lt;h4 id=&#34;clarification&#34;&gt;Clarification:&lt;/h4&gt;

&lt;p&gt;What should we return when needle is an empty string? This is a great question to ask during an interview.&lt;/p&gt;

&lt;p&gt;For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C&amp;rsquo;s strstr() and Java&amp;rsquo;s indexOf().&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;haystack字符串减去needle字符串长度减少循环的次数。&lt;br /&gt;
如果当前haystack字符串中有字符等于needle的首字符，则开启循环遍历。&lt;br /&gt;
如果循环的次数等于needle字符串长度，则说明字符串匹配，返回开始匹配的首字符的索引。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n*j), 空间复杂度：O(1)。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 97.03% of C++ online submissions for Implement strStr().&lt;/li&gt;
&lt;li&gt;Memory Usage: 9.1 MB, less than 74.01% of C++ online submissions for Implement strStr().&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int strStr(string haystack, string needle) {
        int lenh = haystack.size();
        int lenn = needle.size();
        if(lenn == 0) return 0;
        for(int i = 0; i &amp;lt;= lenh - lenn; ++i){
            if(haystack[i] == needle[0]){
                for(int j = 0; j &amp;lt; lenn &amp;amp;&amp;amp; haystack[i + j] == needle[j]; ++j)
                    if(j == lenn - 1) return i; 
            }
        }
        return -1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang 内存对齐</title>
      <link>https://cuckooemm.xyz/2019/june/golang-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/golang-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</guid>
      <description>

&lt;h1 id=&#34;golang-内存对齐&#34;&gt;Golang 内存对齐&lt;/h1&gt;

&lt;p&gt;golang结构体中变量的顺序不同为结构体分配的内存大小也不同。&lt;/p&gt;

&lt;p&gt;先来看一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Part1 struct {
	a bool
	b int32
	c int8
	d int64
	e byte
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;bool  一个字节&lt;/li&gt;
&lt;li&gt;int32 四个字节&lt;/li&gt;
&lt;li&gt;int8  一个字节&lt;/li&gt;
&lt;li&gt;int64 八个字节&lt;/li&gt;
&lt;li&gt;byte  一个字节&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以应分配的内存空间为&lt;code&gt;1 + 4 + 1 + 8 + 1 = 15&lt;/code&gt;个字节。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Part1 struct {
    a bool
	b int32
	c int8
	d int64
	e byte
}

func main() {
	part1 := Part1{}
	fmt.Printf(&amp;quot;part1 size: %d, align: %d\n&amp;quot;, unsafe.Sizeof(part1), unsafe.Alignof(part1))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;part1 size: 32, align: 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终输出占用内存为32字节，与前面的计算结果并不一致。&lt;br /&gt;
而造成这种情况的原因就是内存对齐。&lt;br /&gt;
接下来改变一下字段的顺序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Part1 struct {
	a bool
	b int32
	c int8
	d int64
	e byte
}

type Part2 struct {
	e byte
	c int8
	a bool
	b int32
	d int64
}

func main() {
	part1 := Part1{}
	part2 := Part2{}

	fmt.Printf(&amp;quot;part1 size: %d, align: %d\n&amp;quot;, unsafe.Sizeof(part1), unsafe.Alignof(part1))
	fmt.Printf(&amp;quot;part2 size: %d, align: %d\n&amp;quot;, unsafe.Sizeof(part2), unsafe.Alignof(part2))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;part1 size: 32, align: 8
part2 size: 16, align: 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发现，仅仅只是改变的结构体字段的顺序，内存占用的空间就减少了一半。&lt;/p&gt;

&lt;h3 id=&#34;为什么要内存对齐&#34;&gt;为什么要内存对齐&lt;/h3&gt;

&lt;p&gt;CPU读取主存是一件耗时的操作，所以CPU并不会一个一个字节的去内存读取数据，而是以块为单位在内存上读取数据。块的大小可以为：2、4、8、16 字节等大小，称其为内存访问粒度。如果访问未对齐的内存，一次访问能完成的事情便需要两次，并且为了提高内存的利用率，我们需要进行内存对齐。&lt;/p&gt;

&lt;h3 id=&#34;默认系数&#34;&gt;默认系数&lt;/h3&gt;

&lt;p&gt;在不同平台上的编译器都有自己默认的 “对齐系数”，可通过预编译命令 #pragma pack(n) 进行变更，n 就是代指 “对齐系数”。一般来讲，我们常用的平台的系数如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;32 位：4&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;64 位：8&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外要注意，不同硬件平台占用的大小和对齐值都可能是不一样的。&lt;/p&gt;

&lt;h3 id=&#34;成员对齐&#34;&gt;成员对齐&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {
	fmt.Printf(&amp;quot;bool align: %d\n&amp;quot;, unsafe.Alignof(bool(true)))
	fmt.Printf(&amp;quot;int32 align: %d\n&amp;quot;, unsafe.Alignof(int32(0)))
	fmt.Printf(&amp;quot;int8 align: %d\n&amp;quot;, unsafe.Alignof(int8(0)))
	fmt.Printf(&amp;quot;int64 align: %d\n&amp;quot;, unsafe.Alignof(int64(0)))
	fmt.Printf(&amp;quot;byte align: %d\n&amp;quot;, unsafe.Alignof(byte(0)))
	fmt.Printf(&amp;quot;string align: %d\n&amp;quot;, unsafe.Alignof(&amp;quot;EDDYCJY&amp;quot;))
	fmt.Printf(&amp;quot;map align: %d\n&amp;quot;, unsafe.Alignof(map[string]string{}))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;bool align: 1
int32 align: 4
int8 align: 1
int64 align: 8
byte align: 1
string align: 8
map align: 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Go 中可以调用 &lt;code&gt;unsafe.Alignof()&lt;/code&gt; 来返回相应类型的对齐系数。通过观察输出结果，可得知基本都是 2&lt;sup&gt;n&lt;/sup&gt;，最大也不会超过 8。64位机编译器默认对齐系数是 8，因此最大值不会超过这个数。&lt;/p&gt;

&lt;h3 id=&#34;对齐规则&#34;&gt;对齐规则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为编译器默认对齐长度（#pragma pack(n)）或当前成员变量类型的长度（unsafe.Sizeof），取最小值作为当前类型的对齐值。其偏移量必须为对齐值的整数倍&lt;/li&gt;
&lt;li&gt;结构体本身，对齐值必须为编译器默认对齐长度（#pragma pack(n)）或结构体的所有成员变量类型中的最大长度，取最大数的最小整数倍作为对齐值&lt;/li&gt;
&lt;li&gt;结合以上两点，可得知若编译器默认对齐长度（#pragma pack(n)）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;成员变量&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;类型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;偏移量&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;自身占用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;a&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bool&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;字节对齐&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;b&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;int32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;c&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;int8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;字节对齐&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;d&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;int64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;e&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;byte&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;24&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;字节对齐&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;25&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;总占用大小&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;内存分配分析&#34;&gt;内存分配分析&lt;/h3&gt;

&lt;h4 id=&#34;未进行内存对齐&#34;&gt;未进行内存对齐&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;第一个成员 a

&lt;ul&gt;
&lt;li&gt;类型为 bool&lt;/li&gt;
&lt;li&gt;大小/对齐值为 1 字节&lt;/li&gt;
&lt;li&gt;初始地址，偏移量为 0。占用了第 1 位&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第二个成员 b

&lt;ul&gt;
&lt;li&gt;类型为 int32&lt;/li&gt;
&lt;li&gt;大小/对齐值为 4 字节&lt;/li&gt;
&lt;li&gt;根据规则 1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此 2-4 位为 Padding。而当前数值从第 5 位开始填充，到第 8 位。如下：axxx|bbbb&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第三个成员 c

&lt;ul&gt;
&lt;li&gt;类型为 int8&lt;/li&gt;
&lt;li&gt;大小/对齐值为 1 字节&lt;/li&gt;
&lt;li&gt;根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 8。不需要额外对齐，填充 1 个字节到第 9 位。如下：axxx|bbbb|c&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第四个成员 d

&lt;ul&gt;
&lt;li&gt;类型为 int64&lt;/li&gt;
&lt;li&gt;大小/对齐值为 8 字节&lt;/li&gt;
&lt;li&gt;根据规则 1，其偏移量必须为 8 的整数倍。确定偏移量为 16，因此 9-16 位为 Padding。而当前数值从第 17 位开始写入，到第 24 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第五个成员 e

&lt;ul&gt;
&lt;li&gt;类型为 byte&lt;/li&gt;
&lt;li&gt;大小/对齐值为 1 字节&lt;/li&gt;
&lt;li&gt;根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 24。不需要额外对齐，填充 1 个字节到第 25 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd|e&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;内存对齐之后&#34;&gt;内存对齐之后&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;第一个成员 e

&lt;ul&gt;
&lt;li&gt;类型为 byte&lt;/li&gt;
&lt;li&gt;大小/对齐值为 1 字节&lt;/li&gt;
&lt;li&gt;初始地址，偏移量为 0。占用了第 1 位&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第二个成员 c

&lt;ul&gt;
&lt;li&gt;类型为 int8&lt;/li&gt;
&lt;li&gt;大小/对齐值为 1 字节&lt;/li&gt;
&lt;li&gt;根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 2。不需要额外对齐&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第三个成员 a

&lt;ul&gt;
&lt;li&gt;类型为 bool&lt;/li&gt;
&lt;li&gt;大小/对齐值为 1 字节&lt;/li&gt;
&lt;li&gt;根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 3。不需要额外对齐&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第四个成员 b

&lt;ul&gt;
&lt;li&gt;类型为 int32&lt;/li&gt;
&lt;li&gt;大小/对齐值为 4 字节&lt;/li&gt;
&lt;li&gt;根据规则1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此第 3 位为 Padding。而当前数值从第 4 位开始填充，到第 8 位。如下：ecax|bbbb&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第五个成员 d

&lt;ul&gt;
&lt;li&gt;类型为 int64&lt;/li&gt;
&lt;li&gt;大小/对齐值为 8 字节&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Part1 内存布局：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx&lt;br /&gt;
Part2 内存布局：ecax|bbbb|dddd|dddd&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 25 - Reverse Nodes in k Group [Hard]</title>
      <link>https://cuckooemm.xyz/2019/june/25-reverse-nodes-in-k-group/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/25-reverse-nodes-in-k-group/</guid>
      <description>

&lt;h1 id=&#34;25-reverse-nodes-in-k-group&#34;&gt;25.Reverse Nodes in k Group&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/reverse-nodes-in-k-group/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Hard&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.&lt;/p&gt;

&lt;p&gt;k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.&lt;/p&gt;

&lt;p&gt;给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。&lt;/p&gt;

&lt;p&gt;k 是一个正整数，它的值小于或等于链表的长度。&lt;/p&gt;

&lt;p&gt;如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。&lt;/p&gt;

&lt;h3 id=&#34;实例&#34;&gt;实例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;Given this linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5&lt;/p&gt;

&lt;p&gt;For k = 2, you should return: 2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5&lt;/p&gt;

&lt;p&gt;For k = 3, you should return: 3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;Only constant extra memory is allowed.&lt;br /&gt;
You may not alter the values in the list&amp;rsquo;s nodes, only nodes itself may be changed.&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;首先循环k次，则k以前的链表则是需要交换的链表。&lt;br /&gt;
可以使用递归的方法，&lt;strong&gt;空间复杂度O(k)。&lt;/strong&gt;&lt;br /&gt;
在这里使用了指针交换的方法。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(1)。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 20 ms, faster than 91.59% of C++ online submissions for Reverse Nodes in k-Group.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9.9 MB, less than 56.39% of C++ online submissions for Reverse Nodes in k-Group.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(head == NULL) return head;
        ListNode* res = new ListNode(0);
        ListNode* cur = head;
        res-&amp;gt;next = head;
        ListNode* resc = res;
        ListNode* curp;
        while(head != NULL){
            cur = head;
            for(int i = 0; i &amp;lt; k; ++i){                // 判断下一个轮是否够k个数
                if(head == NULL) return  res-&amp;gt;next;
                head = head-&amp;gt;next;
            }
            for(int i = 1; i &amp;lt; k; ++i){                // N数只需交换n-1次
                curp = cur-&amp;gt;next;
                cur-&amp;gt;next = curp-&amp;gt;next;
                curp-&amp;gt;next = resc-&amp;gt;next;
                resc-&amp;gt;next = curp;                
            }
            for(int i = 0; i &amp;lt; k; ++i){
                resc = resc-&amp;gt;next;                     // 更新头部指针
            }
        }
        return res-&amp;gt;next;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>