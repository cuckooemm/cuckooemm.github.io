<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cuckooemm&#39;s Blog on Cuckooemm&#39;s Blog</title>
    <link>https://cuckooemm.xyz/</link>
    <description>Recent content in Cuckooemm&#39;s Blog on Cuckooemm&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 11 Jul 2019 23:58:01 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Leetcode - 43 - Multiply Strings [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/43-multiply-strings/</link>
      <pubDate>Thu, 11 Jul 2019 23:58:01 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/43-multiply-strings/</guid>
      <description>

&lt;h1 id=&#34;43-multiply-strings&#34;&gt;43.Multiply Strings&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/multiply-strings/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.&lt;/p&gt;

&lt;p&gt;给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;The length of both num1 and num2 is &amp;lt; 110.&lt;/li&gt;
&lt;li&gt;Both num1 and num2 contain only digits 0-9.&lt;/li&gt;
&lt;li&gt;Both num1 and num2 do not contain any leading zero, except the number 0 itself.&lt;/li&gt;
&lt;li&gt;You must not use any built-in BigInteger library or convert the inputs to integer directly.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; num1 = &amp;ldquo;2&amp;rdquo;, num2 = &amp;ldquo;3&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;6&amp;rdquo;&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; num1 = &amp;ldquo;123&amp;rdquo;, num2 = &amp;ldquo;456&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;56088&amp;rdquo;&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;两个字符串位数从右往左数，第一个数的第i位与第二个数的第j位相乘，会影响乘积的第i+j和第i+j-1位。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 74.92% of C++ online submissions for Multiply Strings.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9 MB, less than 39.84% of C++ online submissions for Multiply Strings.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    string multiply(string num1, string num2) {
        if(num1 == &amp;quot;0&amp;quot; || num2 == &amp;quot;0&amp;quot;) return &amp;quot;0&amp;quot;;
        int len1 = num1.size(), len2 = num2.size(),tmpl;
        string res = &amp;quot;&amp;quot;;
        vector&amp;lt;int&amp;gt; tmp(len1 + len2);
        for(int i = len1 - 1; i &amp;gt;= 0; --i){
            tmpl = len1 + len2 - 2 - i;
            for(int j = len2 - 1; j &amp;gt;= 0; --j){
                tmp[tmpl - j] += (num1[i] - 48) * (num2[j] - 48);
            }
        }
        for(int i = 0; i &amp;lt; len1 + len2 - 1; ++i){
            tmp[i + 1] += tmp[i] / 10;
            tmp[i] %= 10;
            res.insert(0,1,tmp[i] + 48);
        }
        if(0 != tmp[len1 + len2 - 1])
            res.insert(0,1,tmp[len1 + len2 - 1] + 48);
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 42 - Trapping Rain Water [Hard]</title>
      <link>https://cuckooemm.xyz/2019/july/42-trapping-rain-water/</link>
      <pubDate>Thu, 11 Jul 2019 21:48:35 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/42-trapping-rain-water/</guid>
      <description>

&lt;h1 id=&#34;42-trapping-rain-water&#34;&gt;42.Trapping Rain Water&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/trapping-rain-water/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Hard&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.&lt;/p&gt;

&lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example&#34;&gt;Example:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [0,1,0,2,1,0,1,3,2,1,2,1]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 6&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;使用双指针指向两端，积水高度由两边指针决定。&lt;br /&gt;
遍历时维护lmax和rmax，如果当前高度低于*max，则计算积水量。&lt;br /&gt;
如果当前高度高于或等于*max，则更改lmax(rmax)。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 72.98% of C++ online submissions for Trapping Rain Water.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9 MB, less than 86.30% of C++ online submissions for Trapping Rain Water.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int trap(vector&amp;lt;int&amp;gt;&amp;amp; height) {
        int l = 0, r = height.size() - 1;
        int res  = 0;
        int lmax = 0, rmax = 0;
        while(l &amp;lt; r){
            if(height[l] &amp;lt; height[r]){
                if(height[l] &amp;gt;= lmax)
                    lmax = height[l];
                else
                    res += lmax - height[l];
                ++l;
            }else{
                if(height[r] &amp;gt;= rmax)
                    rmax = height[r];
                else
                    res += rmax - height[r];
                --r;
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 41 - First Missing Positive [Hard]</title>
      <link>https://cuckooemm.xyz/2019/july/41-first-missing-positive/</link>
      <pubDate>Thu, 11 Jul 2019 13:09:57 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/41-first-missing-positive/</guid>
      <description>

&lt;h1 id=&#34;41-first-missing-positive&#34;&gt;41.First Missing Positive&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/first-missing-positive/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Hard&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given an unsorted integer array, find the smallest missing positive integer.&lt;/p&gt;

&lt;p&gt;给定一个未排序的整数数组，找出其中没有出现的最小的正整数。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,2,0]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 3&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [3,4,-1,1]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 2&lt;/p&gt;

&lt;h4 id=&#34;example-3&#34;&gt;Example 3:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [7,8,9,11,12]&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 1&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;Your algorithm should run in O(n) time and uses constant extra space.&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;利用桶排序的思路。&lt;br /&gt;
负数与大于数组长度的数字不考虑。&lt;br /&gt;
用数组中的数当作索引，存放在nums[i] - 1 的索引位置。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 0 ms, faster than 100.00% of C++ online submissions for First Missing Positive.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 30.44% of C++ online submissions for First Missing Positive.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int firstMissingPositive(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        if(nums.size() &amp;lt; 1)
            return 1;
        for(int i = 0; i &amp;lt; nums.size(); ++i){
            while(nums[i] &amp;gt; 0 &amp;amp;&amp;amp; nums[i] &amp;lt;= nums.size() &amp;amp;&amp;amp; nums[nums[i] - 1] != nums[i]){
                swap(nums[i],nums[nums[i] - 1]);
            }
        }
        for(int i = 0; i &amp;lt; nums.size(); ++i){
            if(nums[i] != i + 1){
                return i + 1;
            }
        }
        return nums.size() + 1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 40 - Combination Sum II [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/40-combination-sum-ii/</link>
      <pubDate>Tue, 09 Jul 2019 22:22:41 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/40-combination-sum-ii/</guid>
      <description>

&lt;h1 id=&#34;40-combination-sum-ii&#34;&gt;40.Combination Sum II&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum-ii/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.&lt;/p&gt;

&lt;p&gt;Each number in candidates may only be used once in the combination.&lt;/p&gt;

&lt;p&gt;给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。&lt;/p&gt;

&lt;p&gt;candidates 中的每个数字在每个组合中只能使用一次。&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The solution set must not contain duplicate combinations.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所有数字（包括目标数）都是正整数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解集不能包含重复的组合。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; candidates = [10,1,2,7,6,1,5], target = 8,&lt;br /&gt;
A solution set is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; candidates = [2,5,2,1,2], target = 5,&lt;br /&gt;
A solution set is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[
  [1,2,2],
  [5]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;与Combination Sum 方法一致，因不包含重复项所以递归时从当前push数组下标的下一个位置开始。排序解决重复项问题。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 99.44% of C++ online submissions for Combination Sum II.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9.1 MB, less than 59.13% of C++ online submissions for Combination Sum II.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
private:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    vector&amp;lt;int&amp;gt; tmp;
    void dfs(vector&amp;lt;int&amp;gt;&amp;amp; candidates,int target,int index){
        if(target == 0)
            return res.push_back(tmp);
        for(int i = index; i &amp;lt; candidates.size(); ++i){
            if(candidates[i] &amp;gt; target) break;
            if(index != i &amp;amp;&amp;amp; candidates[i] == candidates[i - 1])
                continue;
            tmp.push_back(candidates[i]);
            dfs(candidates,target - candidates[i],i + 1);            // 数字只能选取一次，从当前索引位置+1
            tmp.pop_back();
        }
    }
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum2(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) {
        sort(candidates.begin(),candidates.end());
        dfs(candidates,target,0);
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 39 - Combination Sum [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/39-combination-sum/</link>
      <pubDate>Tue, 09 Jul 2019 16:25:26 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/39-combination-sum/</guid>
      <description>

&lt;h1 id=&#34;39-combination-sum&#34;&gt;39.Combination Sum&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.&lt;/p&gt;

&lt;p&gt;The same repeated number may be chosen from candidates unlimited number of times.&lt;/p&gt;

&lt;p&gt;给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。&lt;/p&gt;

&lt;p&gt;candidates 中的数字可以无限制重复被选取。&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The solution set must not contain duplicate combinations.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所有数字（包括 target）都是正整数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解集不能包含重复的组合。 &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; candidates = [2,3,6,7], target = 7,&lt;br /&gt;
A solution set is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[  
  [7],  
  [2,2,3]  
]  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; candidates = [2,3,5], target = 8,&lt;br /&gt;
A solution set is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[  
  [2,2,2,2],  
  [2,3,3],  
  [3,5]  
]  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;递归回溯。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 98.70% of C++ online submissions for Combination Sum.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9.7 MB, less than 58.59% of C++ online submissions for Combination Sum.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
private:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    vector&amp;lt;int&amp;gt; temp;
    void dfs(vector&amp;lt;int&amp;gt;&amp;amp; candidates,int target,int index){
        if(target == 0)
            return res.push_back(temp);
        for(; index &amp;lt; candidates.size(); ++index){
            if(candidates[index] &amp;gt; target) continue;
            temp.push_back(candidates[index]);
            dfs(candidates,target - candidates[index],index);        // 数字可被无限次选取，沿用当前位置索引
            temp.pop_back();
        }
    }
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) {
        dfs(candidates,target,0);
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 38 - Count and Say [Easy]</title>
      <link>https://cuckooemm.xyz/2019/july/38-count-and-say/</link>
      <pubDate>Mon, 08 Jul 2019 17:32:57 +0800</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/38-count-and-say/</guid>
      <description>

&lt;h1 id=&#34;38-count-and-say&#34;&gt;38.Count and Say&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/count-and-say/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;The count-and-say sequence is the sequence of integers with the first five terms as following:&lt;/p&gt;

&lt;p&gt;报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;     1
     11
     21
     1211
     111221
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;1 is read off as &amp;ldquo;one 1&amp;rdquo; or 11.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;11 is read off as &amp;ldquo;two 1s&amp;rdquo; or 21.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;21 is read off as &amp;ldquo;one 2, then one 1&amp;rdquo; or 1211.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;1 被读作  &amp;rdquo;one 1&amp;rdquo;  (&amp;ldquo;一个一&amp;rdquo;) , 即 11。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;11 被读作 &amp;rdquo;two 1s&amp;rdquo; (&amp;ldquo;两个一&amp;rdquo;）, 即 21。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;21 被读作 &amp;rdquo;one 2&amp;rdquo;,  &amp;rdquo;one 1&amp;rdquo; （&amp;rdquo;一个二&amp;rdquo; ,  &amp;rdquo;一个一&amp;rdquo;) , 即 1211。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.&lt;/p&gt;

&lt;p&gt;给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。&lt;/p&gt;

&lt;h4 id=&#34;note-each-term-of-the-sequence-of-integers-will-be-represented-as-a-string&#34;&gt;Note: Each term of the sequence of integers will be represented as a string.&lt;/h4&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 1&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;1&amp;rdquo;&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 4&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;1211&amp;rdquo;&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;使用循环依次计算后项。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 0 ms, faster than 100.00% of C++ online submissions for Count and Say.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 80.15% of C++ online submissions for Count and Say.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    string countAndSay(int n) {
        string curRes = &amp;quot;1&amp;quot;;
        string res = &amp;quot;&amp;quot;;
        int curIndex = 2,count = 1;
        while(curIndex &amp;lt;= n){
            res = &amp;quot;&amp;quot;;
            for(int i = 0; i &amp;lt; curRes.size(); ++i){
                if(i+1 &amp;lt; curRes.size() &amp;amp;&amp;amp; curRes[i] == curRes[i + 1]){
                    ++count;
                }else{
                    res.push_back(count + 48);
                    res.push_back(curRes[i]);
                    count = 1;
                }
            }
            curRes = res;
            ++curIndex;
        }
        return curRes;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 35 - Search Insert Position [Easy]</title>
      <link>https://cuckooemm.xyz/2019/july/35-search-insert-position/</link>
      <pubDate>Sun, 07 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/35-search-insert-position/</guid>
      <description>

&lt;h1 id=&#34;35-search-insert-position&#34;&gt;35.Search Insert Position&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-insert-position/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.&lt;/p&gt;

&lt;p&gt;You may assume no duplicates in the array.&lt;/p&gt;

&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;

&lt;p&gt;你可以假设数组中无重复元素。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,3,5,6], 5&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 2&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,3,5,6], 2&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 1&lt;/p&gt;

&lt;h4 id=&#34;example-3&#34;&gt;Example 3:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,3,5,6], 7&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 4&lt;/p&gt;

&lt;h4 id=&#34;example-4&#34;&gt;Example 4:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [1,3,5,6], 0&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 0&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;二分法。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 74.90% of C++ online submissions for Search Insert Position.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.9 MB, less than 59.90% of C++ online submissions for Search Insert Position.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
        int mid = 0, l = 0, r = nums.size() - 1;
        while(l &amp;lt;= r){
            mid = (r - l &amp;gt;&amp;gt; 1) + l;
            if(nums[mid] == target)
                return mid;
            else if(nums[mid] &amp;gt; target)
                r = mid - 1;
            else
                l = mid + 1;
        }
        return l;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 36 - Valid Sudoku [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/36-valid-sudoku/</link>
      <pubDate>Sun, 07 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/36-valid-sudoku/</guid>
      <description>

&lt;h1 id=&#34;36-valid-sudoku&#34;&gt;36.Valid Sudoku&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/valid-sudoku/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:&lt;/p&gt;

&lt;p&gt;1.Each row must contain the digits 1-9 without repetition.&lt;br /&gt;
2.Each column must contain the digits 1-9 without repetition.&lt;br /&gt;
3.Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.&lt;/p&gt;

&lt;p&gt;The Sudoku board could be partially filled, where empty cells are filled with the character &amp;lsquo;.&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。&lt;/p&gt;

&lt;p&gt;数字 1-9 在每一行只能出现一次。&lt;br /&gt;
数字 1-9 在每一列只能出现一次。&lt;br /&gt;
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。&lt;/p&gt;

&lt;p&gt;数独部分空格内已填入了数字，空白格用 &amp;rsquo;.&amp;lsquo; 表示。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[
  [&amp;quot;5&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;],
  [&amp;quot;4&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;],
  [&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;5&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;9&amp;quot;]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt; true&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;[
  [&amp;quot;8&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;],
  [&amp;quot;4&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;],
  [&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;5&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;9&amp;quot;]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt; false
&lt;strong&gt;Explanation:&lt;/strong&gt; Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8&amp;rsquo;s in the top left 3x3 sub-box, it is invalid.&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;A Sudoku board (partially filled) could be valid but is not necessarily solvable.&lt;br /&gt;
Only the filled cells need to be validated according to the mentioned rules.&lt;br /&gt;
The given board contain only digits 1-9 and the character &amp;lsquo;.&amp;rsquo;.&lt;br /&gt;
The given board size is always 9x9.&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;使用数组分别保存每行每列出现过的数字。&lt;br /&gt;
期中，box_index = row / 3 * 3 + columns / 3。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 20 ms, faster than 43.73% of C++ online submissions for Valid Sudoku.&lt;/li&gt;
&lt;li&gt;Memory Usage: 10.8 MB, less than 28.58% of C++ online submissions for Valid Sudoku.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool isValidSudoku(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) {
        vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; r(9,vector&amp;lt;bool&amp;gt;(9,false));
        vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; c(9,vector&amp;lt;bool&amp;gt;(9,false));
        vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; b(9,vector&amp;lt;bool&amp;gt;(9,false));
        int index = 0,b_index = 0;
        for(int i = 0; i &amp;lt; 9; ++i)
            for(int j = 0; j &amp;lt; 9; ++j){
                if(board[i][j] != &#39;.&#39;){
                    index = board[i][j] - 49;
                    b_index = i / 3 * 3 + j / 3;
                    if(r[i][index] || c[j][index] || b[b_index][index]){
                        return false;
                    }else{
                        r[i][index] = true;
                        c[j][index] = true;
                        b[b_index][index] = true;
                    }
                }
            }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 33 - Search in Rotated Sorted Array [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/33-search-in-rotated-sorted-array/</link>
      <pubDate>Sat, 06 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/33-search-in-rotated-sorted-array/</guid>
      <description>

&lt;h1 id=&#34;33-search-in-rotated-sorted-array&#34;&gt;33.Search in Rotated Sorted Array&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-in-rotated-sorted-array/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;/p&gt;

&lt;p&gt;(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).&lt;/p&gt;

&lt;p&gt;You are given a target value to search. If found in the array return its index, otherwise return -1.&lt;/p&gt;

&lt;p&gt;You may assume no duplicate exists in the array.&lt;/p&gt;

&lt;p&gt;Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).&lt;/p&gt;

&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;

&lt;p&gt;( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。&lt;/p&gt;

&lt;p&gt;搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。&lt;/p&gt;

&lt;p&gt;你可以假设数组中不存在重复的元素。&lt;/p&gt;

&lt;p&gt;你的算法时间复杂度必须是 O(log n) 级别。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; nums = [4,5,6,7,0,1,2], target = 0&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 4&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; nums = [4,5,6,7,0,1,2], target = 3&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; -1&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;题目要求 O(log n) 级别复杂度，所以采用&lt;strong&gt;二分法&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 0 ms, faster than 100.00% of C++ online submissions for Search in Rotated Sorted Array.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.5 MB, less than 99.60% of C++ online submissions for Search in Rotated Sorted Array.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
        int l = 0,r = nums.size() - 1;
        int mid = 0;
        while(l &amp;lt;= r){
            mid = (r - l &amp;gt;&amp;gt; 1) + l;                             // 防止加法溢出
            if(nums[mid] == target) return mid; 
            if(nums[mid] &amp;gt;= nums[l]){                           // 说明mid左边有序
                if(nums[mid] &amp;gt; target &amp;amp;&amp;amp; nums[l] &amp;lt;= target)     // 查看mid是否在左区间
                    r = mid - 1;
                else
                    l = mid + 1;
            }else{                                              // 等同 mid &amp;lt; r
                if(nums[mid] &amp;lt; target &amp;amp;&amp;amp; nums[r] &amp;gt;= target)     // 查看mid是否在右区间
                    l = mid + 1;
                else
                    r = mid - 1;
            }
        }
        return -1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 34 - Find First and Last Position of Element in Sorted Array [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/34-find-first-and-last-position-of-element-in-sorted-array/</link>
      <pubDate>Sat, 06 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/34-find-first-and-last-position-of-element-in-sorted-array/</guid>
      <description>

&lt;h1 id=&#34;34-find-first-and-last-position-of-element-in-sorted-array&#34;&gt;34.Find First and Last Position of Element in Sorted Array&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.&lt;/p&gt;

&lt;p&gt;Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).&lt;/p&gt;

&lt;p&gt;If the target is not found in the array, return [-1, -1].&lt;/p&gt;

&lt;p&gt;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。&lt;/p&gt;

&lt;p&gt;你的算法时间复杂度必须是 O(log n) 级别。&lt;/p&gt;

&lt;p&gt;如果数组中不存在目标值，返回 [-1, -1]。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; nums = [5,7,7,8,8,10], target = 8&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; [3,4]&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; nums = [5,7,7,8,8,10], target = 6&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; [-1,-1]&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;题目要求 O(log n) 级别复杂度，所以采用&lt;strong&gt;二分法&lt;/strong&gt;。&lt;br /&gt;
先找到target的索引，然后以此为中心，在左半区找最小索引，右半区找最大索引。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 90.94% of C++ online submissions for Find First and Last Position of Element in Sorted Array.&lt;/li&gt;
&lt;li&gt;Memory Usage: 10.2 MB, less than 76.14% of C++ online submissions for Find First and Last Position of Element in Sorted Array.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; searchRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
        int mid = 0, l = 0, r = nums.size() - 1;
        int lm = l, rm = r;
        vector&amp;lt;int&amp;gt; res(2,-1);
        while(l &amp;lt;= r){
            mid = (r - l &amp;gt;&amp;gt; 1) + l;
            if(nums[mid] == target){
                lm = mid;
                rm = mid;
                while(l &amp;lt;= lm){                 // 在[l,lm]中找最小索引
                    mid = (lm - l &amp;gt;&amp;gt; 1) + l;
                    if(nums[mid] == target){
                        lm = mid - 1;
                        res[0] = mid;
                    }else
                        l = mid + 1;
                }
                while(rm &amp;lt;= r){                 // 在[rm,r]中找最大索引
                    mid = (r - rm &amp;gt;&amp;gt; 1) + rm;
                    if(nums[mid] == target){
                        rm = mid + 1;
                        res[1] = mid;
                    }else
                        r = mid - 1;
                }
                break;                          // 跳出循环
            }else if(target &amp;gt; nums[mid]){
                l = mid + 1;
            }else
                r = mid - 1;
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang 代理</title>
      <link>https://cuckooemm.xyz/2019/july/golang-%E4%BB%A3%E7%90%86/</link>
      <pubDate>Fri, 05 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/golang-%E4%BB%A3%E7%90%86/</guid>
      <description>

&lt;h1 id=&#34;解决golang依赖网络问题&#34;&gt;解决golang依赖网络问题&lt;/h1&gt;

&lt;p&gt;添加环境变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;key: GOPROXY     value: https://goproxy.io
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 29 - Divide Two Integers [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/29-divide-two-integers/</link>
      <pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/29-divide-two-integers/</guid>
      <description>

&lt;h1 id=&#34;29-divide-two-integers&#34;&gt;29.Divide Two Integers&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/divide-two-integers/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.&lt;/p&gt;

&lt;p&gt;Return the quotient after dividing dividend by divisor.&lt;/p&gt;

&lt;p&gt;The integer division should truncate toward zero.&lt;/p&gt;

&lt;p&gt;给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。&lt;/p&gt;

&lt;p&gt;返回被除数 dividend 除以除数 divisor 得到的商。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; dividend = 10, divisor = 3&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 3&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; dividend = 7, divisor = -3&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; -2&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;Both dividend and divisor will be 32-bit signed integers.&lt;br /&gt;
The divisor will never be 0.&lt;br /&gt;
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2&lt;sup&gt;31&lt;/sup&gt;,  2&lt;sup&gt;31&lt;/sup&gt; − 1].
For the purpose of this problem, assume that your function returns 2&lt;sup&gt;31&lt;/sup&gt; − 1 when the division result overflows.&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;余数可以用被除数减去除数求得。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;每次减完除数翻倍，倍数记录翻的倍数。如果当前除数大于被除数，则缩小。位移操作实现。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;异或判断符号。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(log(n)), 空间复杂度：O(1)。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 93.13% of C++ online submissions for Divide Two Integers.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.3 MB, less than 53.98% of C++ online submissions for Divide Two Integers.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int divide(int dividend, int divisor) {
        if(dividend == -2147483648 &amp;amp;&amp;amp; divisor == -1) return INT_MAX;   // 溢出的输入直接返回
        if(divisor == 1) return dividend;                              // 除数为1直接返回
        long long dd = abs((long long)dividend);                       // -2147483648 的绝对值大于int类型的最大整数
        long long dr = abs((long long)divisor);
        int res = 0;                                                   // 保存结果
        int times = 1;                                                 // 倍数
        while(dd &amp;gt;= dr || times &amp;gt; 1){
            if(dd &amp;gt;= dr){
                dd -= dr;
                res += times;
                dr = dr &amp;lt;&amp;lt; 1;                                          // 除数扩大一倍
                times = times &amp;lt;&amp;lt; 1;                                    // 倍数也扩大一倍
            }else{
                dr = dr &amp;gt;&amp;gt; 1;                                          // 除数缩小一倍
                times = times &amp;gt;&amp;gt; 1;                                    // 倍数缩小一倍
            }
        }
        return (dividend ^ divisor) &amp;gt;= 0 ? res : -res;                 // 异或判断符号是否不等
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 31 - Next Permutation [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/31-next-permutation/</link>
      <pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/31-next-permutation/</guid>
      <description>

&lt;h1 id=&#34;31-next-permutation&#34;&gt;31.Next Permutation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/next-permutation/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.&lt;/p&gt;

&lt;p&gt;If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).&lt;/p&gt;

&lt;p&gt;The replacement must be in-place and use only constant extra memory.&lt;/p&gt;

&lt;p&gt;Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.&lt;/p&gt;

&lt;p&gt;实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。&lt;/p&gt;

&lt;p&gt;如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。&lt;/p&gt;

&lt;p&gt;必须原地修改，只允许使用额外常数空间。&lt;/p&gt;

&lt;p&gt;以下是一些例子，输入位于左侧列，其相应输出位于右侧列。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;p&gt;1,2,3 → 1,3,2&lt;br /&gt;
3,2,1 → 1,2,3&lt;br /&gt;
1,1,5 → 1,5,1&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;从右往左遍历，如果i小于i+1的值则退出循环。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在i到end的区间内寻找最小的大于当前i位置值的数交换。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;反转i之后的数字。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 8 ms, faster than 92.20% of C++ online submissions for Next Permutation.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 55.56% of C++ online submissions for Next Permutation.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    void nextPermutation(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int i = nums.size() - 2;
        while(i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[i + 1]){
            --i;
        }
        if(i &amp;gt;= 0){
            int j = nums.size() - 1;
            while(j &amp;gt; i &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[j]){
                --j;
            }
            swap(nums[i],nums[j]);
        }
        reverse(nums,i + 1);
    }
    void reverse(vector&amp;lt;int&amp;gt;&amp;amp; nums,int start){
        int r = nums.size() - 1;
        while(start &amp;lt; r){
            swap(nums[start],nums[r]);
            ++start;
            --r;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 27 - Remove Element [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/27-remove-element/</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/27-remove-element/</guid>
      <description>

&lt;h1 id=&#34;27-remove-element&#34;&gt;27.Remove Element&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/remove-element/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given an array nums and a value val, remove all instances of that value in-place and return the new length.&lt;/p&gt;

&lt;p&gt;Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.&lt;/p&gt;

&lt;p&gt;The order of elements can be changed. It doesn&amp;rsquo;t matter what you leave beyond the new length.&lt;/p&gt;

&lt;p&gt;给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。&lt;/p&gt;

&lt;p&gt;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;

&lt;p&gt;元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;Given nums = [3,2,2,3], val = 3,&lt;/p&gt;

&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 2.&lt;/p&gt;

&lt;p&gt;It doesn&amp;rsquo;t matter what you leave beyond the returned length.&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;Given nums = [0,1,2,2,3,0,4,2], val = 2,&lt;/p&gt;

&lt;p&gt;Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.&lt;/p&gt;

&lt;p&gt;Note that the order of those five elements can be arbitrary.&lt;/p&gt;

&lt;p&gt;It doesn&amp;rsquo;t matter what values are set beyond the returned length.&lt;/p&gt;

&lt;h4 id=&#34;clarification&#34;&gt;Clarification:&lt;/h4&gt;

&lt;p&gt;Confused why the returned value is an integer but your answer is an array?&lt;/p&gt;

&lt;p&gt;Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.&lt;/p&gt;

&lt;p&gt;Internally you can think of this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// nums is passed in by reference. (i.e., without making a copy)
int len = removeElement(nums, val);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i &amp;lt; len; i++) {
    print(nums[i]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;遍历nums,如果数组内值与目标值不等，且当前已经出现过目标值，则把i位置的值赋给l位置。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(1)。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 89.95% of C++ online submissions for Remove Element.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.7 MB, less than 54.44% of C++ online submissions for Remove Element.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int removeElement(vector&amp;lt;int&amp;gt;&amp;amp; nums, int val) {
        int l = 0;
        for(int i = 0; i &amp;lt; nums.size(); ++i){
            if(nums[i] != val){
                if(i != l){
                    nums[l++] = nums[i];
                }else{
                    ++l;
                }
            }
        }
        return l;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Leetcode - 28 - Implment StrStr() [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/28-implment-strstr/</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/28-implment-strstr/</guid>
      <description>

&lt;h1 id=&#34;28-implment-strstr&#34;&gt;28.Implment StrStr()&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/implement-strstr/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Implement strStr().&lt;/p&gt;

&lt;p&gt;Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack&lt;/p&gt;

&lt;p&gt;实现 strStr() 函数。&lt;/p&gt;

&lt;p&gt;给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; haystack = &amp;ldquo;hello&amp;rdquo;, needle = &amp;ldquo;ll&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 2&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; haystack = &amp;ldquo;aaaaa&amp;rdquo;, needle = &amp;ldquo;bba&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; -1&lt;/p&gt;

&lt;h4 id=&#34;clarification&#34;&gt;Clarification:&lt;/h4&gt;

&lt;p&gt;What should we return when needle is an empty string? This is a great question to ask during an interview.&lt;/p&gt;

&lt;p&gt;For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C&amp;rsquo;s strstr() and Java&amp;rsquo;s indexOf().&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;haystack字符串减去needle字符串长度减少循环的次数。&lt;br /&gt;
如果当前haystack字符串中有字符等于needle的首字符，则开启循环遍历。&lt;br /&gt;
如果循环的次数等于needle字符串长度，则说明字符串匹配，返回开始匹配的首字符的索引。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n*j), 空间复杂度：O(1)。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 97.03% of C++ online submissions for Implement strStr().&lt;/li&gt;
&lt;li&gt;Memory Usage: 9.1 MB, less than 74.01% of C++ online submissions for Implement strStr().&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int strStr(string haystack, string needle) {
        int lenh = haystack.size();
        int lenn = needle.size();
        if(lenn == 0) return 0;
        for(int i = 0; i &amp;lt;= lenh - lenn; ++i){
            if(haystack[i] == needle[0]){
                for(int j = 0; j &amp;lt; lenn &amp;amp;&amp;amp; haystack[i + j] == needle[j]; ++j)
                    if(j == lenn - 1) return i; 
            }
        }
        return -1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>