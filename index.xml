<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cuckooemm&#39;s Blog on Cuckooemm&#39;s Blog</title>
    <link>https://cuckooemm.xyz/</link>
    <description>Recent content in Cuckooemm&#39;s Blog on Cuckooemm&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 02 Jun 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LeetCode - 6 - ZigZag Conversion [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/6-zigzag_conversion/</link>
      <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/6-zigzag_conversion/</guid>
      <description>

&lt;h1 id=&#34;6-zigzag-conversion&#34;&gt;6.ZigZag Conversion&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/zigzag-conversion/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;The string &lt;code&gt;&amp;quot;PAYPALISHIRING&amp;quot;&lt;/code&gt; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)&lt;br /&gt;
使字符串以给定行数上进行Z字形书写，像下面这样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;P   A   H   N
A P L S I I G
Y   I   R
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then read line by line: &lt;code&gt;&amp;quot;PAHNAPLSIIGYIR&amp;quot;&lt;/code&gt;&lt;br /&gt;
然后一行一行的读。&lt;br /&gt;
Write the code that will take a string and make this conversion given a number of rows:&lt;br /&gt;
编写代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;string convert(string s, int numRows);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; s = &amp;ldquo;PAYPALISHIRING&amp;rdquo;, numRows = 3&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;PAHNAPLSIIGYIR&amp;rdquo;&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; s = &amp;ldquo;PAYPALISHIRING&amp;rdquo;, numRows = 4&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;PINALSIGYAHRPI&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;P     I    N
A   L S  I G
Y A   H R
P     I
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;就是计算字符串下标。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;行&lt;code&gt;0&lt;/code&gt;中的字符位于索引&lt;code&gt;k&lt;/code&gt;(2 * numRows - 2)处。&lt;/li&gt;
&lt;li&gt;行&lt;code&gt;numRows-1&lt;/code&gt;中的字符位于索引&lt;code&gt;k&lt;/code&gt;(2 * numRows − 2) + numRows − 1处;&lt;/li&gt;
&lt;li&gt;内部的行&lt;code&gt;i&lt;/code&gt;中的字符位于索引&lt;code&gt;k&lt;/code&gt;(2 * numRows − 2) + i 以及 (2 * numRows − 2) − i处;&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(n)&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 12 ms, faster than 94.01% of C++ online submissions for ZigZag Conversion.&lt;/li&gt;
&lt;li&gt;Memory Usage: 10.2 MB, less than 85.33% of C++ online submissions for ZigZag Conversion.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    string convert(string s, int numRows) {
        if(s.size() == 0 | numRows == 1){
            return s;
        }
        string res = &amp;quot;&amp;quot;;
        int n = s.size();
        int size = (numRows &amp;lt;&amp;lt; 1) - 2;
        int temp = 0;
        for(int i = 0; i &amp;lt; numRows; ++i){
            for(int j = i; j &amp;lt; n; j += size){
                res += s[j];
                temp = j + size - (i &amp;lt;&amp;lt; 1);
                if(i != 0 &amp;amp;&amp;amp; i != numRows - 1 &amp;amp;&amp;amp; temp &amp;lt; n)
                    res += s[temp];
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 7 - Reverse Integer [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/7-reverse_integer/</link>
      <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/7-reverse_integer/</guid>
      <description>

&lt;h1 id=&#34;7-reverse-integer&#34;&gt;7.Reverse Integer&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/reverse-integer/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a 32-bit signed integer, reverse digits of an integer.&lt;/p&gt;

&lt;p&gt;给定一个32位有符号整数，对整数的每位数字进行反转。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 123&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 321&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; -123&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; -321&lt;/p&gt;

&lt;h4 id=&#34;example-3&#34;&gt;Example 3:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 120&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 21&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2&lt;sup&gt;31&lt;/sup&gt;,  2&lt;sup&gt;31&lt;/sup&gt; − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.&lt;/p&gt;

&lt;p&gt;假设我们的环境只能存储32位范围内的带符号整数：[−2&lt;sup&gt;31&lt;/sup&gt;,  2&lt;sup&gt;31&lt;/sup&gt; − 1]。整数反转溢出时返回0。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;主要是溢出判断&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(log&lt;sub&gt;10&lt;/sub&gt;(x)), 空间复杂度：O(1)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 0 ms, faster than 100.00% of C++ online submissions for Reverse Integer.&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.5 MB, less than 54.65% of C++ online submissions for Reverse Integer.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int reverse(int x) {
        int rev = 0;
        while (x != 0) {
            int pop = x % 10;
            x /= 10;
            if (rev &amp;gt; INT_MAX / 10 || (rev == INT_MAX / 10 &amp;amp;&amp;amp; pop &amp;gt; 7)) return 0;
            if (rev &amp;lt; INT_MIN / 10 || (rev == INT_MIN / 10 &amp;amp;&amp;amp; pop &amp;lt; -8)) return 0;
            rev = rev * 10 + pop;
        }
        return rev;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 8 - String to Integer(atoi) [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/8-string_to_integer_atoi/</link>
      <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/8-string_to_integer_atoi/</guid>
      <description>

&lt;h1 id=&#34;8-string-to-integer-atoi&#34;&gt;8.String to Integer(atoi)&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/string-to-integer-atoi/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Implement atoi which converts a string to an integer.&lt;/p&gt;

&lt;p&gt;The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.&lt;/p&gt;

&lt;p&gt;The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.&lt;/p&gt;

&lt;p&gt;If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.&lt;/p&gt;

&lt;p&gt;If no valid conversion could be performed, a zero value is returned.&lt;/p&gt;

&lt;p&gt;请你来实现一个 atoi 函数，使其能将字符串转换成整数。&lt;/p&gt;

&lt;p&gt;首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。&lt;/p&gt;

&lt;p&gt;当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。&lt;/p&gt;

&lt;p&gt;该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。&lt;/p&gt;

&lt;p&gt;注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。&lt;/p&gt;

&lt;p&gt;在任何情况下，若函数不能进行有效的转换时，请返回 0。&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;p&gt;Only the space character &amp;lsquo; &amp;rsquo; is considered as whitespace character.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2&lt;sup&gt;31&lt;/sup&gt;,  2&lt;sup&gt;31&lt;/sup&gt; − 1]. If the numerical value is out of the range of representable values, INT_MAX (2&lt;sup&gt;31&lt;/sup&gt; − 1) or INT_MIN (−2&lt;sup&gt;31&lt;/sup&gt;) is returned.&lt;/p&gt;

&lt;p&gt;假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2&lt;sup&gt;31&lt;/sup&gt;,  2&lt;sup&gt;31&lt;/sup&gt; − 1]。如果数值超过这个范围，qing返回  INT_MAX (2&lt;sup&gt;31&lt;/sup&gt; − 1) 或 INT_MIN (−2&lt;sup&gt;31&lt;/sup&gt;) 。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; &amp;ldquo;42&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 42&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; &amp;ldquo;   -42&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; -42&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; 第一个非空白字符为 &amp;lsquo;-&amp;rsquo;, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。&lt;/p&gt;

&lt;h4 id=&#34;example-3&#34;&gt;Example 3:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; &amp;ldquo;4193 with words&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 4193&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; 转换截止于数字 &amp;lsquo;3&amp;rsquo; ，因为它的下一个字符不为数字。&lt;/p&gt;

&lt;h4 id=&#34;example-4&#34;&gt;Example 4:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; &amp;ldquo;words and 987&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 0&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; 第一个非空字符是 &amp;lsquo;w&amp;rsquo;, 但它不是数字或正、负号。因此无法执行有效的转换。&lt;/p&gt;

&lt;h4 id=&#34;example-5&#34;&gt;Example 5:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; &amp;ldquo;-91283472332&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; -2147483648&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; 数字 &amp;ldquo;-91283472332&amp;rdquo; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−2&lt;sup&gt;31&lt;/sup&gt;) 。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;先排除空格与确定正负号，遇到除了空格、数字和正负号的情况返回0。&lt;br /&gt;
用long long 类型做结果储存，减少冗余的判断溢出代码。&lt;br /&gt;
用字符的ASCII码减去48(&amp;lsquo;0&amp;rsquo;)即为int型数字。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n)), 空间复杂度：O(1)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 96.33% of C++ online submissions for String to Integer (atoi).&lt;/li&gt;
&lt;li&gt;Memory Usage: 8.3 MB, less than 87.42% of C++ online submissions for String to Integer (atoi).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int myAtoi(string str) {
        int i = 0,flag = 1;              // 用 1、-1控制数字正负
        for(;i &amp;lt; str.size();++i){
            if(str[i] &amp;gt; 47 &amp;amp;&amp;amp; str[i] &amp;lt; 58){
                break;
            }else if(str[i] == &#39;+&#39;){
                ++i;
                break;
            }else if(str[i] == &#39;-&#39;){
                ++i;
                flag = -1;               // 负数置flag为-1
                break;
            }else if(str[i] == &#39; &#39;){  
                continue;
            }else{
                return 0;
            }
        }
        long long res = 0;
        for(;i &amp;lt; str.size();++i){
            if(str[i] &amp;gt; 47 &amp;amp;&amp;amp; str[i] &amp;lt; 58){
                res = res * 10 + str[i] - 48;
                if(res * flag &amp;lt; INT_MIN) // 判断溢出
                    return INT_MIN;
                if(res * flag &amp;gt; INT_MAX)
                    return INT_MAX;
            }else{                       // 不为数字则不继续转换
                break;
            }
        }
        return res * flag;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 1 - Two Sum [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/1-two_sum/</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/1-two_sum/</guid>
      <description>

&lt;h1 id=&#34;1-tow-sum&#34;&gt;1.Tow Sum&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/two-sum/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Easy&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific &lt;code&gt;target&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You may assume that each input would have exactly one solution, and you may not use the same element twice.&lt;/p&gt;

&lt;p&gt;给定一个整型数组，返回数组中值的和&lt;code&gt;target&lt;/code&gt;的数组索引，可以假定每个输入都有一个解，且同一个元素不能使用两次。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;p&gt;Given nums = [2, 7, 11, 15], target = 9,&lt;br /&gt;
Because nums[0] + nums[1] = 2 + 7 = 9,&lt;br /&gt;
return [0, 1].&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;空间复杂度优先:&lt;br /&gt;
首先对数组进行排序，左指针指向数组头，右指针指向数组长度-1，左指针+右指针。
如果结果大于target,右指针&amp;ndash;，反之左指针++。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(nlogn), 空间复杂度：O(1)&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;时间复杂度优先:&lt;br /&gt;
字典法,顺序读取元素，把target-element的值保存字典。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(n)&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 4 ms, faster than 99.94% of C++ online submissions for Two Sum.&lt;/li&gt;
&lt;li&gt;Memory Usage: 10.4 MB, less than 21.52% of C++ online submissions for Two Sum.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;h4 id=&#34;字典法&#34;&gt;字典法&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
	unordered_map&amp;lt;int, int&amp;gt; map(nums.size());
	vector&amp;lt;int&amp;gt; result(2);
	for(int i = 0; i &amp;lt; nums.size(); i++)    // 元素大小为key,value为索引
	{
		map[nums[i]] = i;
	}
	for (int i = 0; i &amp;lt; nums.size(); i++)
	{
		int t = target - nums[i];
		if (map.count(t) &amp;amp;&amp;amp; map[t] != i)    // 判断不是同一个元素
		{
			result[0] = i;
			result[1] = map[t];
			break;
		}
	}
	return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 2 - Add Two Numbers [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/2-add_two_number/</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/2-add_two_number/</guid>
      <description>

&lt;h1 id=&#34;2-add-two-numbers&#34;&gt;2.Add Two Numbers&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/add-two-numbers/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.&lt;/p&gt;

&lt;p&gt;You may assume the two numbers do not contain any leading zero, except the number 0 itself.&lt;/p&gt;

&lt;p&gt;给定两个非空链表用来表示两个非负整数，它们各自的位数是按照逆序的方式存储的，并且每个节点只能存储一位数字。用链表返回它们的和。&lt;br /&gt;
你可以假设它们都不会以0开头，除了数字0。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 7 -&amp;gt; 0 -&amp;gt; 8&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; 342 + 465 = 807.&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;用l1作为结果存放位置，节省空间与内存申请的时间。&lt;br /&gt;
之前用第三个链表保存结果，这次写博客又想到了用&lt;code&gt;l1&lt;/code&gt;参数自身保存结果，空间复杂度降到了&lt;code&gt;O(1)&lt;/code&gt;。&lt;br /&gt;
没什么说的，挺简单的中等难度题。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(max(l1,l2)), 空间复杂度：O(1)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 20 ms, faster than 97.42% of C++ online submissions for Add Two Numbers.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9.9 MB, less than 96.42% of C++ online submissions for Add Two Numbers.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int t = 0;                 //保存进位
        ListNode* list = l1;       // 保存头结点
        ListNode* pre;             // 保存l1的上一个节点
        while(l1 != NULL &amp;amp;&amp;amp; l2 != NULL){
            t += l1-&amp;gt;val + l2-&amp;gt;val;
            pre = l1;
            l1-&amp;gt;val = t % 10;
            t /= 10;
            l1 = l1-&amp;gt;next;
            l2 = l2-&amp;gt;next;
        }
        if(l2 != NULL){           // l2 不为NULL 
           pre-&amp;gt;next = l2;        // 则把l2接到l1
           l1 = pre-&amp;gt;next;        // 之前的l1指针已被更改 需重新赋值
        }
        while(l1 != NULL){
            if(t != 0){           // 循环 存在 1 + 9一直存在进位的情况
                t += l1-&amp;gt;val;
                pre = l1;
                l1-&amp;gt;val = t % 10;
                t /= 10;
                l1 = l1-&amp;gt;next;
            }else{
                return list;     // t=0 直接返回
            }
        }
        if(t != 0){              // 如果l1 l2 同时为NULL 则可能产生进位情况
            pre-&amp;gt;next = new ListNode(t);
        }
        return list;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode - 3 - Longest Substring Without Repeating Characters [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/3-longest_substring_without_repeating_characters/</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/3-longest_substring_without_repeating_characters/</guid>
      <description>

&lt;h1 id=&#34;3-longest-substring-without-repeating-characters&#34;&gt;3.Longest Substring Without Repeating Characters&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-substring-without-repeating-characters/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;地址&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;难度：Medium&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;Given a string, find the length of the longest substring without repeating characters.&lt;/p&gt;

&lt;p&gt;给定一个字符串，找出不含重复字符的最长子串。&lt;/p&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; &amp;ldquo;abcabcbb&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 3&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; The answer is &amp;ldquo;abc&amp;rdquo;, with the length of 3.&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example 2&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; &amp;ldquo;bbbbb&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 1&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; The answer is &amp;ldquo;b&amp;rdquo;, with the length of 1.&lt;/p&gt;

&lt;h4 id=&#34;example-3&#34;&gt;Example 3&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; &amp;ldquo;bbbbb&amp;rdquo;&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 1&lt;br /&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; The answer is &amp;ldquo;b&amp;rdquo;, with the length of 1.&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;h4 id=&#34;双指针&#34;&gt;双指针&lt;/h4&gt;

&lt;p&gt;用7位ASCII码值作为key保存出现过的字符，定义一个左指针，循环比较字典中保存的字符的索引是否大于左指针，如果当前字典中字符的值大于左指针，说明之前已经出现，把上次出现的索引保存到start,然后把新的出现的位置保存到字典，再比较本次长度与上次长度比较赋值给len,返回最大长度。&lt;br /&gt;
&lt;strong&gt;时间复杂度:O(n), 空间复杂度：O(1)&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;ac&#34;&gt;AC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runtime: 12 ms, faster than 94.97% of C++ online submissions for Longest Substring Without Repeating Characters.&lt;/li&gt;
&lt;li&gt;Memory Usage: 9.8 MB, less than 85.66% of C++ online submissions for Longest Substring Without Repeating Characters.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector&amp;lt;int&amp;gt; dict(128,-1);     // 用ASCII作key，初始值为-1(int数组无法赋初始值为-1，踩了半天这坑)。
        int start = -1,len = 0;       // 初始左指针位置
        for(int i = 0; i &amp;lt; s.size(); ++i){
            if(dict[s[i]] &amp;gt; start){   // 值大于start说明出现重复
                start = dict[s[i]];   // 把重复的位置保存到左指针
            }
            dict[s[i]] = i;           // 根据key把值改为索引
            len = max(len,i - start); // 比较每次的字符串长度
        }
        return len;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Git(2)</title>
      <link>https://cuckooemm.xyz/2019/may/git2/</link>
      <pubDate>Sat, 25 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/may/git2/</guid>
      <description>

&lt;h3 id=&#34;分支&#34;&gt;分支&lt;/h3&gt;

&lt;h4 id=&#34;创建分支&#34;&gt;创建分支&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;-b&lt;/code&gt; 表示创建并切换&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git checkout -b &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等同于&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git branch &amp;lt;name&amp;gt;
git checkout &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;查看当前分支&#34;&gt;查看当前分支&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;git branch&lt;/code&gt;命令会列出所有分支，当前分支前面会标一个&lt;code&gt;*&lt;/code&gt;号。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git branch
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;切换分支&#34;&gt;切换分支&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git checkout &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;合并分支&#34;&gt;合并分支&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git merge &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git merge&lt;/code&gt;命令用于合并指定分支到当前分支。 &lt;code&gt;Fast-forward&lt;/code&gt; 信息表示快进模式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git merge --no-ff -m &amp;quot;merge with no-ff&amp;quot; &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--no-ff&lt;/code&gt;参数，表示禁用&lt;code&gt;Fast forward&lt;/code&gt;
因为本次合并要创建一个新的commit，所以加上&lt;code&gt;-m&lt;/code&gt;参数，把&lt;code&gt;commit&lt;/code&gt;描述写进去。&lt;/p&gt;

&lt;h4 id=&#34;删除分支&#34;&gt;删除分支&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git branch -d &amp;lt;name&amp;gt; 
git branch -D &amp;lt;name&amp;gt; //未合并过的分支删除
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;环境保存与恢复&#34;&gt;环境保存与恢复&lt;/h3&gt;

&lt;h4 id=&#34;保存现场&#34;&gt;保存现场&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git stash
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;查看现场保存位置&#34;&gt;查看现场保存位置&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git stash list
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;现场恢复&#34;&gt;现场恢复&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git stash apply&lt;/code&gt; 恢复现场但不删除记录，调用&lt;code&gt;git stash drop&lt;/code&gt;删除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git stash pop&lt;/code&gt; 恢复且删除&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git stash &amp;lt;apply or pop&amp;gt; &amp;lt;stash&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;标签&#34;&gt;标签&lt;/h3&gt;

&lt;h4 id=&#34;创建标签&#34;&gt;创建标签&lt;/h4&gt;

&lt;p&gt;在当前分支打标签&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git tag &amp;lt;tagname&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定commitid 打标签&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git tag  &amp;lt;tagname&amp;gt; &amp;lt;commitid&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为标签添加说明&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git tag -a &amp;lt;tagname&amp;gt; -m &amp;quot;explain&amp;quot; &amp;lt;commitid&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;查看所有标签&#34;&gt;查看所有标签&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git tag 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;查看标签信息&#34;&gt;查看标签信息&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git show &amp;lt;tagname&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;标签删除&#34;&gt;标签删除&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git tag -d &amp;lt;tagname&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;远程删除&#34;&gt;远程删除&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git push &amp;lt;host&amp;gt; :refs/tags/&amp;lt;tagname&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;标签推送&#34;&gt;标签推送&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git push &amp;lt;host&amp;gt; &amp;lt;tagname&amp;gt;
git push &amp;lt;host&amp;gt; --tags // 推送所有
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Git(1)</title>
      <link>https://cuckooemm.xyz/2019/may/git1/</link>
      <pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/may/git1/</guid>
      <description>

&lt;h1 id=&#34;git命令&#34;&gt;Git命令&lt;/h1&gt;

&lt;p&gt;写一下git的命令以便忘记时查找&lt;/p&gt;

&lt;h3 id=&#34;获取帮助&#34;&gt;获取帮助&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git help &amp;lt;verb&amp;gt;
git &amp;lt;verb&amp;gt; --help
man git-&amp;lt;verv&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;config&#34;&gt;config&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;git config针对一个git仓库&lt;/li&gt;
&lt;li&gt;git config &amp;ndash;global针对一个用户&lt;/li&gt;
&lt;li&gt;sudo git config &amp;ndash;system针对一个系统，因为是针对整个系统的，所以必须使用sudo&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;个人信息&#34;&gt;个人信息&lt;/h4&gt;

&lt;p&gt;用于提交git时显示的个人信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git config --global user.name &amp;quot;your name&amp;quot;
git config --global user.email &amp;quot;your email&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;仓库独立指定&#34;&gt;仓库独立指定&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git config user.name &amp;quot;your name&amp;quot;
git config user.email &amp;quot;your email&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不加 - -global&lt;/p&gt;

&lt;h4 id=&#34;配置编辑器&#34;&gt;配置编辑器&lt;/h4&gt;

&lt;p&gt;默认缺省编辑器 为vi or vim。 如想使用emacs&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git config --global core.editor emacs
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;配置比较工具&#34;&gt;配置比较工具&lt;/h4&gt;

&lt;p&gt;用于解决合并时的冲突，如vimdiff&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git config --global merge.tool vimdiff
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;配置别名&#34;&gt;配置别名&lt;/h4&gt;

&lt;p&gt;如 git status 设置别名 st&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git config --global alias.st status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推荐设置别名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git config --global alias.lg &amp;quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&amp;lt;%an&amp;gt;%Creset&#39; --abbrev-commit&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入&lt;code&gt;q&lt;/code&gt;退出&lt;/p&gt;

&lt;h4 id=&#34;检查配置&#34;&gt;检查配置&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git config --list
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;删除config-key值&#34;&gt;删除config key值&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git config --global --unset key
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;gitignore文件&#34;&gt;.gitignore文件&lt;/h4&gt;

&lt;p&gt;设置文件监控规则
文档描述gitignore语法规则有五条：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;忽略空白行或以#开始的行（注释）；&lt;/li&gt;
&lt;li&gt;按照标准glob工作，并递归应用于整个工作目录（参考glob）；&lt;/li&gt;
&lt;li&gt;模式以/打头，禁止递归工作；&lt;/li&gt;
&lt;li&gt;模式以/结尾，限定特定目录；&lt;/li&gt;
&lt;li&gt;使用感叹号!对模式含义取反；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;gitignore规则细化补充如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通用的规则应该写在前面，专有的放后面。&lt;/li&gt;
&lt;li&gt;规则中不含有/的，则当作通配符处理，每个目录迭代检查；&lt;/li&gt;
&lt;li&gt;规则以/结尾的，仅限于目录，而不包含同名的链接和文件；&lt;/li&gt;
&lt;li&gt;模式以连续两个星号和/打头(**/)时，和移除**/含义相同；&lt;/li&gt;
&lt;li&gt;模式以连续两个型号结尾时，表示匹配其下一切内容，含子目录；&lt;/li&gt;
&lt;li&gt;模式中间包含/**/时，**匹配0个或多个目录；比如：&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;克隆git仓库到本地&#34;&gt;克隆git仓库到本地&lt;/h3&gt;

&lt;h4 id=&#34;clone&#34;&gt;clone&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git clone url //支持git、http(s)、ssh等协议
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认只有&lt;code&gt;master&lt;/code&gt;分支&lt;/p&gt;

&lt;h5 id=&#34;链接分支&#34;&gt;链接分支&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;在本地创建和远程分支对应的分支，使用&lt;code&gt;git checkout -b branch-name origin/branch-name&lt;/code&gt;，本地和远程分支的名称最好一致&lt;/li&gt;
&lt;li&gt;建立本地分支和远程分支的关联，使用git branch &amp;ndash;set-upstream branch-name origin/branch-name&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;fetch&#34;&gt;fetch&lt;/h4&gt;

&lt;p&gt;拉取远程更新到本地，可指定分支 对本地代码无影响&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git fetch &amp;lt;shortname&amp;gt; &amp;lt;分支名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;pull&#34;&gt;pull&lt;/h4&gt;

&lt;p&gt;拉取远程分支的更新并合并 远程分支与当前分支合并可省略&lt;code&gt;:&lt;/code&gt;后部分&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git pull &amp;lt;shortname&amp;gt; &amp;lt;远程分之名&amp;gt;:&amp;lt;本地分支名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认在本地分支与远程分支建立追踪关系
也可以手动建立追踪关系&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git branch --set-upstream &amp;lt;分支&amp;gt; \&amp;lt;分支&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果远程分支已删除 pull不会删除本地分支&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git pull -p //本地删除远程已删除的分支
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;push&#34;&gt;push&lt;/h4&gt;

&lt;p&gt;推送本地更新，与 pull相仿
如果远程分支不存在，则新建&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git push &amp;lt;shortname&amp;gt; &amp;lt;本地分支&amp;gt;:&amp;lt;远程分支&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;省略本地分支名 等于删除远程分支&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git push &amp;lt;shortname&amp;gt; :&amp;lt;远程分支&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等同&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git push &amp;lt;shortname&amp;gt; --delete master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果存在多个远程追踪关系，使用&lt;code&gt;-u&lt;/code&gt;指定一个默认主机&lt;/p&gt;

&lt;h3 id=&#34;添加文件&#34;&gt;添加文件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git add .  // 把所有变化提交到暂存区 包括修改和新建 不包括删除
git add -u // 把添加的文件中修改的文件提交到暂存区(包含删除) 不添加新文件
git add -A // all
git add &amp;lt;file&amp;gt;... // 可添加多个文件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://git-scm.com/docs/git-add&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;官网文档&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;查看当前文件状态&#34;&gt;查看当前文件状态&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git status
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;查看已暂存和未暂存的更改&#34;&gt;查看已暂存和未暂存的更改&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git diff
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;以暂存的和上次提交的更改&#34;&gt;以暂存的和上次提交的更改&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git diff --cached 
git diff --staged
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;提交&#34;&gt;提交&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git commit //启动默认编辑器输入更新说明
git commit -m &amp;quot;更新内容&amp;quot; // 加-m 在之后输入更新说明
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;跳过使用暂存区域&#34;&gt;跳过使用暂存区域&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git commit -a // 跳过 add 步骤
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;移除文件&#34;&gt;移除文件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rm &amp;lt;file&amp;gt;...&lt;/code&gt;
移除版本控制并从工作目录中删除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git rm -f &amp;lt;file&amp;gt;...&lt;/code&gt;
移除已添加到暂存区的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git rm --cached &amp;lt;file&amp;gt;&lt;/code&gt;
不进行版本控制但保留文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;移动文件-or-改名&#34;&gt;移动文件 or 改名&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git mv file_from file_to 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;code&gt;git mv&lt;/code&gt;相当于下面三条命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;mv README.txt README
git rm README.txt
git add README
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;撤销修改&#34;&gt;撤销修改&lt;/h3&gt;

&lt;p&gt;使文件回到最后一次&lt;code&gt;add&lt;/code&gt; or &lt;code&gt;commit&lt;/code&gt; 时的状态&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git checkout -- &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;版本回退&#34;&gt;版本回退&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git log  查看记录
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;HEAD 表示当前版本&lt;/li&gt;
&lt;li&gt;上一个为 HEAD^&lt;/li&gt;
&lt;li&gt;上上个为 HEAD^^&lt;/li&gt;
&lt;li&gt;上100个为 HEAD~100&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也可指定回退版本的commitid
&lt;code&gt;--hard&lt;/code&gt; 彻底回退到某个版本
&lt;code&gt;--soft&lt;/code&gt; 只回退 commit 信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git rest --hard HEAD^
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;撤销回退&#34;&gt;撤销回退&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git rest --hard commitid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git reflog&lt;/code&gt; 记录HEAD的修改&lt;/p&gt;

&lt;h3 id=&#34;远程库管理&#34;&gt;远程库管理&lt;/h3&gt;

&lt;h4 id=&#34;列出管理的远程库&#34;&gt;列出管理的远程库&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git remote -v 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;本地关联远程库&#34;&gt;本地关联远程库&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git remote add &amp;lt;shortname&amp;gt; url
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;远程库重命名&#34;&gt;远程库重命名&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git remote rename &amp;lt;oldname&amp;gt; &amp;lt;newname&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;删除关联远程库&#34;&gt;删除关联远程库&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git remote rm &amp;lt;shortname&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://cuckooemm.xyz/about/</link>
      <pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/about/</guid>
      <description>

&lt;h1 id=&#34;about-me&#34;&gt;About me&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Cuckooemm&lt;/li&gt;
&lt;li&gt;cuckooemm@gmail.com&lt;/li&gt;
&lt;li&gt;后端工程师&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博客刚开通&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang defer解析</title>
      <link>https://cuckooemm.xyz/2019/may/golang-defer%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/may/golang-defer%E8%A7%A3%E6%9E%90/</guid>
      <description>

&lt;h1 id=&#34;golang-defer解析&#34;&gt;Golang defer解析&lt;/h1&gt;

&lt;h3 id=&#34;概念&#34;&gt;概念&lt;/h3&gt;

&lt;p&gt;在go语言中，&lt;code&gt;defer&lt;/code&gt; 是用来在&lt;strong&gt;函数作用域结束之后执行函数的关键字&lt;/strong&gt;，在当前函数返回前调用。延迟函数&lt;code&gt;defer&lt;/code&gt;的实现是由编译器很运行时共同完成的。&lt;/p&gt;

&lt;h3 id=&#34;作用域&#34;&gt;作用域&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {
    {
        defer fmt.Println(&amp;quot;defer runs&amp;quot;)
        fmt.Println(&amp;quot;code block ends&amp;quot;)
    }
    
    fmt.Println(&amp;quot;func ends&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这里我们可以看出，&lt;code&gt;defer&lt;/code&gt;并不是在退出当前代码块的作用域之前执行的，&lt;code&gt;defer&lt;/code&gt;只会在当前函数返回之前被调用。&lt;/p&gt;

&lt;h3 id=&#34;defer规则&#34;&gt;defer规则&lt;/h3&gt;

&lt;h4 id=&#34;1-执行顺序&#34;&gt;1、执行顺序&lt;/h4&gt;

&lt;p&gt;定义&lt;code&gt;defer&lt;/code&gt;类似于入栈，&lt;code&gt;defer&lt;/code&gt;的执行顺序类似于出栈，即先出现的&lt;code&gt;defer&lt;/code&gt;最后执行。
例如在&lt;code&gt;for&lt;/code&gt;循环中&lt;code&gt;defer&lt;/code&gt;打印的结果为：4、3、2、1、0。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {
    for i := 0; i &amp;lt; 5; i++ {
        defer fmt.Println(i)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;的设计初衷是简化函数返回时资源清理的动作。
资源往往有依赖，如申请A资源，在A的基础上申请B资源，再在B的基础上申请C资源，资源的申请顺序为：A-&amp;gt;B-&amp;gt;C;释放时则需要反向进行：C-&amp;gt;B-&amp;gt;A。这就是把&lt;code&gt;defer&lt;/code&gt;设计成&lt;strong&gt;FIFO&lt;/strong&gt;的原因。&lt;/p&gt;

&lt;h4 id=&#34;2-参数确定&#34;&gt;2、参数确定&lt;/h4&gt;

&lt;p&gt;Golang中所有的函数参数传递都是值传递，延迟函数的参数在&lt;code&gt;defer&lt;/code&gt;定义时就已确定下来。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {  // main函数没有参数也没有返回值
    i := 0 
    defer fmt.Println(i)
    i++
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;defer&lt;/code&gt;定义时就已经把参数通过值传递传给了&lt;code&gt;defer&lt;/code&gt;函数，在&lt;code&gt;defer&lt;/code&gt;函数之后对参数i的操作并不会影响&lt;code&gt;defer&lt;/code&gt;函数中的参数i的值，因此函数的打印结果为0。
接下来再看一段代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main(){
    i := 0
    defer func(i int) {
        fmt.Println(&amp;amp;i) 结果为0xc00000a0d8
    }(i)
    fmt.Println(&amp;amp;i)  // 结果为0xc00000a0d0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这里可以看出&lt;code&gt;defer&lt;/code&gt;中的参数&lt;strong&gt;i&lt;/strong&gt;与代码中的参数&lt;strong&gt;i&lt;/strong&gt;已经不是一个参数了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {
    var i *int
    i = new(int) // 申请内存
    *i = 0
    defer func(i *int) {
        fmt.Println(i) // 结果为 0xc000062080
        fmt.Println(*i) // 结果为1
    }(i)
    *i++
    fmt.Println(i) // 结果为 0xc000062080
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于指针类型，延迟函数的参数是一个地址值，而在这样的情况下，&lt;code&gt;defer&lt;/code&gt;后面的语句对变量的修改可能会影响延迟函数的参数值，而&lt;code&gt;defer&lt;/code&gt;函数中的指针参数与&lt;code&gt;defer&lt;/code&gt;外的指针参数又是两个不同的变量，也就是说为指针赋予新的地址值同样不会影响&lt;code&gt;defer&lt;/code&gt;中的指针值。&lt;/p&gt;

&lt;h4 id=&#34;3-延迟函数可能操作主函数的具名返回值&#34;&gt;3、延迟函数可能操作主函数的具名返回值&lt;/h4&gt;

&lt;p&gt;函数返回的&lt;code&gt;return&lt;/code&gt;语句并不是一个原子操作，实际上&lt;code&gt;return&lt;/code&gt;只代理汇编指令&lt;code&gt;ret&lt;/code&gt;，即跳转程序执行。
如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;return i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上分两部执行，即将&lt;strong&gt;i&lt;/strong&gt;值存入栈中作为返回值，然后执行跳转，而&lt;code&gt;defer&lt;/code&gt;的执行时机正是跳转前，所以说defer执行时是有机会操作返回值的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func deferFuncReturn() (result int) {
    i := 1

    defer func() {
       result++
    }()

    return i
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数的&lt;code&gt;return&lt;/code&gt;语句可以拆分成下面两行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;result = i
return
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;延迟函数的执行正是&lt;code&gt;return&lt;/code&gt;之前，加入&lt;code&gt;defer&lt;/code&gt;后的执行过程如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;result = i
result++
return
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数实际返回i++的值。&lt;/p&gt;

&lt;h3 id=&#34;应用场景&#34;&gt;应用场景&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;关闭文件描述符&lt;/li&gt;
&lt;li&gt;关闭数据库连接&lt;/li&gt;
&lt;li&gt;资源解锁&lt;/li&gt;
&lt;li&gt;recover捕获错误&lt;/li&gt;
&lt;li&gt;等&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>