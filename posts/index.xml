<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Cuckooemm&#39;s Blog</title>
    <link>https://cuckooemm.xyz/posts/</link>
    <description>Recent content in Posts on Cuckooemm&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 06 Jul 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://cuckooemm.xyz/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode - 33 - Search in Rotated Sorted Array [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/33-search-in-rotated-sorted-array/</link>
      <pubDate>Sat, 06 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/33-search-in-rotated-sorted-array/</guid>
      <description>33.Search in Rotated Sorted Array 地址
难度：Medium
题目描述 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).</description>
    </item>
    
    <item>
      <title>Leetcode - 34 - Find First and Last Position of Element in Sorted Array [Medium]</title>
      <link>https://cuckooemm.xyz/2019/july/34-find-first-and-last-position-of-element-in-sorted-array/</link>
      <pubDate>Sat, 06 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/34-find-first-and-last-position-of-element-in-sorted-array/</guid>
      <description>34.Find First and Last Position of Element in Sorted Array 地址
难度：Medium
题目描述 Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).
If the target is not found in the array, return [-1, -1].
给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
你的算法时间复杂度必须是 O(log n) 级别。
如果数组中不存在目标值，返回 [-1, -1]。
示例 Example 1: Input: nums = [5,7,7,8,8,10], target = 8</description>
    </item>
    
    <item>
      <title>Golang 代理</title>
      <link>https://cuckooemm.xyz/2019/july/golang-%E4%BB%A3%E7%90%86/</link>
      <pubDate>Fri, 05 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/july/golang-%E4%BB%A3%E7%90%86/</guid>
      <description> 解决golang依赖网络问题 添加环境变量
key: GOPROXY value: https://goproxy.io  </description>
    </item>
    
    <item>
      <title>Leetcode - 29 - Divide Two Integers [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/29-divide-two-integers/</link>
      <pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/29-divide-two-integers/</guid>
      <description>29.Divide Two Integers 地址
难度：Medium
题目描述 Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.
Return the quotient after dividing dividend by divisor.
The integer division should truncate toward zero.
给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。
返回被除数 dividend 除以除数 divisor 得到的商。
示例 Example 1: Input: dividend = 10, divisor = 3
Output: 3
Example 2: Input: dividend = 7, divisor = -3</description>
    </item>
    
    <item>
      <title>Leetcode - 31 - Next Permutation [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/31-next-permutation/</link>
      <pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/31-next-permutation/</guid>
      <description>31.Next Permutation 地址
难度：Medium
题目描述 Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).
The replacement must be in-place and use only constant extra memory.
Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</description>
    </item>
    
    <item>
      <title>Leetcode - 27 - Remove Element [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/27-remove-element/</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/27-remove-element/</guid>
      <description>27.Remove Element 地址
难度：Easy
题目描述 Given an array nums and a value val, remove all instances of that value in-place and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
The order of elements can be changed. It doesn&amp;rsquo;t matter what you leave beyond the new length.
给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</description>
    </item>
    
    <item>
      <title>Leetcode - 28 - Implment StrStr() [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/28-implment-strstr/</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/28-implment-strstr/</guid>
      <description>28.Implment StrStr() 地址
难度：Easy
题目描述 Implement strStr().
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack
实现 strStr() 函数。
给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。
示例 Example 1: Input: haystack = &amp;ldquo;hello&amp;rdquo;, needle = &amp;ldquo;ll&amp;rdquo;
Output: 2
Example 2: Input: haystack = &amp;ldquo;aaaaa&amp;rdquo;, needle = &amp;ldquo;bba&amp;rdquo;
Output: -1
Clarification: What should we return when needle is an empty string?</description>
    </item>
    
    <item>
      <title>Golang 内存对齐</title>
      <link>https://cuckooemm.xyz/2019/june/golang-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/golang-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</guid>
      <description>Golang 内存对齐 golang结构体中变量的顺序不同为结构体分配的内存大小也不同。
先来看一个例子：
type Part1 struct { a bool b int32 c int8 d int64 e byte }   bool 一个字节 int32 四个字节 int8 一个字节 int64 八个字节 byte 一个字节  所以应分配的内存空间为1 + 4 + 1 + 8 + 1 = 15个字节。
type Part1 struct { a bool b int32 c int8 d int64 e byte } func main() { part1 := Part1{} fmt.Printf(&amp;quot;part1 size: %d, align: %d\n&amp;quot;, unsafe.</description>
    </item>
    
    <item>
      <title>Leetcode - 25 - Reverse Nodes in k Group [Hard]</title>
      <link>https://cuckooemm.xyz/2019/june/25-reverse-nodes-in-k-group/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/25-reverse-nodes-in-k-group/</guid>
      <description>25.Reverse Nodes in k Group 地址
难度：Hard
题目描述 Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</description>
    </item>
    
    <item>
      <title>Leetcode - 26 - Remove Duplicates From Sorted Array [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/26-remove-duplicates-from-sorted-array/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/26-remove-duplicates-from-sorted-array/</guid>
      <description>26.Remove Duplicates From Sorted Array 地址
难度：Easy
题目描述 Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
示例 Example 1: Given nums = [1,1,2],
Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</description>
    </item>
    
    <item>
      <title>LeetCode - 24 - Swap Nodes in Pairs [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/24-swap-nodes-in-pairs/</link>
      <pubDate>Fri, 07 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/24-swap-nodes-in-pairs/</guid>
      <description>24.Swap Nodes in Pairs 地址
难度：Medium
题目描述 Given a linked list, swap every two adjacent nodes and return its head.
You may not modify the values in the list&amp;rsquo;s nodes, only nodes itself may be changed.
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例 Example: Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, you should return the list as 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.
思路 交换指针。
时间复杂度:O(n), 空间复杂度：O(1)。
AC  Runtime: 0 ms, faster than 100.00% of C++ online submissions for Swap Nodes in Pairs.</description>
    </item>
    
    <item>
      <title>LeetCode - 23 - Merge k Sorted Lists [Hard]</title>
      <link>https://cuckooemm.xyz/2019/june/23-merge-k-sorted-lists/</link>
      <pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/23-merge-k-sorted-lists/</guid>
      <description>23.Merge k Sorted Lists 地址
难度：Hard
题目描述 Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。
实例 Example: Input:
[
1-&amp;gt;4-&amp;gt;5,
1-&amp;gt;3-&amp;gt;4,
2-&amp;gt;6
]
Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6
思路 使用优先队列解决。 时间复杂度:O(n log k), 空间复杂度：O(k)。
AC  Runtime: 20 ms, faster than 99.55% of C++ online submissions for Merge k Sorted Lists. Memory Usage: 11.3 MB, less than 65.67% of C++ online submissions for Merge k Sorted Lists.</description>
    </item>
    
    <item>
      <title>LeetCode - 17 - Letter Combinations of a Phone Number [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/17-letter-combinations-of-a-phone-number/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/17-letter-combinations-of-a-phone-number/</guid>
      <description>17.Letter Combinations of a Phone Number 地址
难度：Medium
题目描述 Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
示例 Example: Input: &amp;ldquo;23&amp;rdquo;
Output: [&amp;ldquo;ad&amp;rdquo;, &amp;ldquo;ae&amp;rdquo;, &amp;ldquo;af&amp;rdquo;, &amp;ldquo;bd&amp;rdquo;, &amp;ldquo;be&amp;rdquo;, &amp;ldquo;bf&amp;rdquo;, &amp;ldquo;cd&amp;rdquo;, &amp;ldquo;ce&amp;rdquo;, &amp;ldquo;cf&amp;rdquo;].</description>
    </item>
    
    <item>
      <title>LeetCode - 19 - Remove Nth Node From End of List [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/19-remove-nth-node-from-end-of-list/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/19-remove-nth-node-from-end-of-list/</guid>
      <description>19.Remove Nth Node From End of List 地址
难度：Medium
题目描述 Given a linked list, remove the n-th node from the end of list and return its head.
给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。
示例 Example: Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2.
After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.
Note: Given n will always be valid.
Follow up: Could you do this in one pass?</description>
    </item>
    
    <item>
      <title>LeetCode - 20 - Valid Parentheses [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/20-valid-parentheses/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/20-valid-parentheses/</guid>
      <description>20.Valid Parentheses 地址
难度：Easy
题目描述 Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.
An input string is valid if:
 Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.  Note that an empty string is also considered valid.
给定一个只包括 &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39; 的字符串，判断字符串是否有效。</description>
    </item>
    
    <item>
      <title>LeetCode - 21 - Merge Two Sorted Lists [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/21-merge-two-sorted-lists/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/21-merge-two-sorted-lists/</guid>
      <description>21.Merge Two Sorted Lists 地址
难度：Easy
题目描述 Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例 Example: Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4
思路 比较大小然后修改指针。 时间复杂度:O(n), 空间复杂度：O(1)。
AC  Runtime: 0 ms, faster than 100.00% of C++ online submissions for Merge Two Sorted Lists. Memory Usage: 9 MB, less than 60.</description>
    </item>
    
    <item>
      <title>LeetCode - 22 - Generate_Parentheses [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/22-generate-parentheses/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/22-generate-parentheses/</guid>
      <description>22.Generate_Parentheses 地址
难度：Medium
题目描述 Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
For example, given n = 3, a solution set is:
给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。
示例 例如，给出 n = 3，生成结果为：
[ &amp;quot;((()))&amp;quot;, &amp;quot;(()())&amp;quot;, &amp;quot;(())()&amp;quot;, &amp;quot;()(())&amp;quot;, &amp;quot;()()()&amp;quot; ]  思路 使用递归。
AC  Runtime: 4 ms, faster than 96.72% of C++ online submissions for Generate Parentheses. Memory Usage: 17.5 MB, less than 22.52% of C++ online submissions for Generate Parentheses.</description>
    </item>
    
    <item>
      <title>LeetCode - 11 - Container With Most Water [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/11-container-with-most-water/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/11-container-with-most-water/</guid>
      <description>11.Container With Most Water 地址
难度：Medium
题目描述 Given n non-negative integers a1, a2, &amp;hellip;, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
给定 n 个非负整数 a1，a2，&amp;hellip;，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</description>
    </item>
    
    <item>
      <title>LeetCode - 12 - Integer to Roman [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/12-integer-to-roman/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/12-integer-to-roman/</guid>
      <description>12.Integer to Roman 地址
难度：Medium
题目描述 Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000  For example, two is written as II in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, XII, which is simply X + II.</description>
    </item>
    
    <item>
      <title>LeetCode - 13 - Roman to Integer [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/13-roman-to-integer/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/13-roman-to-integer/</guid>
      <description>13.Roman to Integer 地址
难度：Easy
题目描述 Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000  For example, two is written as II in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, XII, which is simply X + II.</description>
    </item>
    
    <item>
      <title>LeetCode - 14 - Longest_Common_Prefix [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/14-longest-common-prefix/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/14-longest-common-prefix/</guid>
      <description>14.Longest_Common_Prefix 地址
难度：Easy
题目描述 Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string &amp;ldquo;&amp;rdquo;.
编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 &amp;ldquo;&amp;ldquo;。
示例 Example 1: Input: [&amp;ldquo;flower&amp;rdquo;,&amp;ldquo;flow&amp;rdquo;,&amp;ldquo;flight&amp;rdquo;]
Output: &amp;ldquo;fl&amp;rdquo;
Example 2: Input: [&amp;ldquo;dog&amp;rdquo;,&amp;ldquo;racecar&amp;rdquo;,&amp;ldquo;car&amp;rdquo;]
Output: &amp;ldquo;&amp;rdquo;
Explanation: There is no common prefix among the input strings.
思路 把第一个元素拷贝，然后依次比较之后的string。
遇到不同则裁剪字符串并跳去循环，开始下一个string。
时间复杂度:O(S), 空间复杂度：O(1)。
AC  Runtime: 4 ms, faster than 98.77% of C++ online submissions for Longest Common Prefix.</description>
    </item>
    
    <item>
      <title>LeetCode - 15 - 3Sum [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/15-3sum/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/15-3sum/</guid>
      <description>15.3Sum 地址
难度：Medium
题目描述 Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。
Note: The solution set must not contain duplicate triplets.
答案中不可以包含重复的三元组。
示例 Example: Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ]  思路 首先对数组进行排序，选择一个数，然后用双指针法对比，如果和大于0，左移右指针，反之，右移左指针。 时间复杂度:O(n2), 空间复杂度：O(1)。</description>
    </item>
    
    <item>
      <title>LeetCode - 16 - 3Sum Closest [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/16-3sum-closest/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/16-3sum-closest/</guid>
      <description>16.3Sum Closest 地址
难度：Medium
题目描述 Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
示例 Example: Given array nums = [-1, 2, 1, -4], and target = 1.</description>
    </item>
    
    <item>
      <title>LeetCode - 9 - Palindrome Number [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/9-palindrome-number/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/9-palindrome-number/</guid>
      <description>9.Palindrome Number 地址
难度：Easy
题目描述 Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
示例 Example 1: Input: 121
Output: true
Example 2: Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
Example 3: Input: 10
Output: false
Explanation: Reads 01 from right to left.</description>
    </item>
    
    <item>
      <title>LeetCode - 6 - ZigZag Conversion [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/6-zigzag-conversion/</link>
      <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/6-zigzag-conversion/</guid>
      <description>6.ZigZag Conversion 地址
难度：Medium
题目描述 The string &amp;quot;PAYPALISHIRING&amp;quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
使字符串以给定行数上进行Z字形书写，像下面这样。
P A H N A P L S I I G Y I R  And then read line by line: &amp;quot;PAHNAPLSIIGYIR&amp;quot;
然后一行一行的读。
Write the code that will take a string and make this conversion given a number of rows:</description>
    </item>
    
    <item>
      <title>LeetCode - 7 - Reverse Integer [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/7-reverse-integer/</link>
      <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/7-reverse-integer/</guid>
      <description>7.Reverse Integer 地址
难度：Easy
题目描述 Given a 32-bit signed integer, reverse digits of an integer.
给定一个32位有符号整数，对整数的每位数字进行反转。
示例 Example 1: Input: 123
Output: 321
Example 2: Input: -123
Output: -321
Example 3: Input: 120
Output: 21
Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</description>
    </item>
    
    <item>
      <title>LeetCode - 8 - String to Integer(atoi) [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/8-string-to-integer-atoi/</link>
      <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/8-string-to-integer-atoi/</guid>
      <description>8.String to Integer(atoi) 地址
难度：Medium
题目描述 Implement atoi which converts a string to an integer.
The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.
The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</description>
    </item>
    
    <item>
      <title>LeetCode - 1 - Two Sum [Easy]</title>
      <link>https://cuckooemm.xyz/2019/june/1-two-sum/</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/1-two-sum/</guid>
      <description>1.Tow Sum 地址
难度：Easy
题目描述 Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
给定一个整型数组，返回数组中值的和target的数组索引，可以假定每个输入都有一个解，且同一个元素不能使用两次。
示例 Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].</description>
    </item>
    
    <item>
      <title>LeetCode - 2 - Add Two Numbers [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/2-add-two-number/</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/2-add-two-number/</guid>
      <description>2.Add Two Numbers 地址
难度：Medium
题目描述 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
给定两个非空链表用来表示两个非负整数，它们各自的位数是按照逆序的方式存储的，并且每个节点只能存储一位数字。用链表返回它们的和。
你可以假设它们都不会以0开头，除了数字0。
示例 Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)</description>
    </item>
    
    <item>
      <title>LeetCode - 3 - Longest Substring Without Repeating Characters [Medium]</title>
      <link>https://cuckooemm.xyz/2019/june/3-longest_substring-without-repeating-characters/</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/june/3-longest_substring-without-repeating-characters/</guid>
      <description>3.Longest Substring Without Repeating Characters 地址
难度：Medium
题目描述 Given a string, find the length of the longest substring without repeating characters.
给定一个字符串，找出不含重复字符的最长子串。
示例 Example 1 Input: &amp;ldquo;abcabcbb&amp;rdquo;
Output: 3
Explanation: The answer is &amp;ldquo;abc&amp;rdquo;, with the length of 3.
Example 2 Input: &amp;ldquo;bbbbb&amp;rdquo;
Output: 1
Explanation: The answer is &amp;ldquo;b&amp;rdquo;, with the length of 1.
Example 3 Input: &amp;ldquo;bbbbb&amp;rdquo;
Output: 1
Explanation: The answer is &amp;ldquo;b&amp;rdquo;, with the length of 1.</description>
    </item>
    
    <item>
      <title>Git(2)</title>
      <link>https://cuckooemm.xyz/2019/may/git2/</link>
      <pubDate>Sat, 25 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/may/git2/</guid>
      <description>分支 创建分支 -b 表示创建并切换
git checkout -b &amp;lt;name&amp;gt;  等同于
git branch &amp;lt;name&amp;gt; git checkout &amp;lt;name&amp;gt;  查看当前分支 git branch命令会列出所有分支，当前分支前面会标一个*号。
git branch  切换分支 git checkout &amp;lt;name&amp;gt;  合并分支 git merge &amp;lt;name&amp;gt;  git merge命令用于合并指定分支到当前分支。 Fast-forward 信息表示快进模式
git merge --no-ff -m &amp;quot;merge with no-ff&amp;quot; &amp;lt;name&amp;gt;  --no-ff参数，表示禁用Fast forward 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。
删除分支 git branch -d &amp;lt;name&amp;gt; git branch -D &amp;lt;name&amp;gt; //未合并过的分支删除  环境保存与恢复 保存现场 git stash  查看现场保存位置 git stash list  现场恢复  git stash apply 恢复现场但不删除记录，调用git stash drop删除 git stash pop 恢复且删除  git stash &amp;lt;apply or pop&amp;gt; &amp;lt;stash&amp;gt;  标签 创建标签 在当前分支打标签</description>
    </item>
    
    <item>
      <title>Git(1)</title>
      <link>https://cuckooemm.xyz/2019/may/git1/</link>
      <pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/may/git1/</guid>
      <description>Git命令 写一下git的命令以便忘记时查找
获取帮助 git help &amp;lt;verb&amp;gt; git &amp;lt;verb&amp;gt; --help man git-&amp;lt;verv&amp;gt;  config  git config针对一个git仓库 git config &amp;ndash;global针对一个用户 sudo git config &amp;ndash;system针对一个系统，因为是针对整个系统的，所以必须使用sudo  个人信息 用于提交git时显示的个人信息
git config --global user.name &amp;quot;your name&amp;quot; git config --global user.email &amp;quot;your email&amp;quot;  仓库独立指定 git config user.name &amp;quot;your name&amp;quot; git config user.email &amp;quot;your email&amp;quot;  不加 - -global
配置编辑器 默认缺省编辑器 为vi or vim。 如想使用emacs
git config --global core.editor emacs  配置比较工具 用于解决合并时的冲突，如vimdiff
git config --global merge.</description>
    </item>
    
    <item>
      <title>Golang defer解析</title>
      <link>https://cuckooemm.xyz/2019/may/golang-defer%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuckooemm.xyz/2019/may/golang-defer%E8%A7%A3%E6%9E%90/</guid>
      <description>Golang defer解析 概念 在go语言中，defer 是用来在函数作用域结束之后执行函数的关键字，在当前函数返回前调用。延迟函数defer的实现是由编译器很运行时共同完成的。
作用域 func main() { { defer fmt.Println(&amp;quot;defer runs&amp;quot;) fmt.Println(&amp;quot;code block ends&amp;quot;) } fmt.Println(&amp;quot;func ends&amp;quot;) }  从这里我们可以看出，defer并不是在退出当前代码块的作用域之前执行的，defer只会在当前函数返回之前被调用。
defer规则 1、执行顺序 定义defer类似于入栈，defer的执行顺序类似于出栈，即先出现的defer最后执行。 例如在for循环中defer打印的结果为：4、3、2、1、0。
func main() { for i := 0; i &amp;lt; 5; i++ { defer fmt.Println(i) } }  defer的设计初衷是简化函数返回时资源清理的动作。
资源往往有依赖，如申请A资源，在A的基础上申请B资源，再在B的基础上申请C资源，资源的申请顺序为：A-&amp;gt;B-&amp;gt;C;释放时则需要反向进行：C-&amp;gt;B-&amp;gt;A。这就是把defer设计成FIFO的原因。
2、参数确定 Golang中所有的函数参数传递都是值传递，延迟函数的参数在defer定义时就已确定下来。
func main() { // main函数没有参数也没有返回值 i := 0 defer fmt.Println(i) i++ }  在defer定义时就已经把参数通过值传递传给了defer函数，在defer函数之后对参数i的操作并不会影响defer函数中的参数i的值，因此函数的打印结果为0。
接下来再看一段代码
func main(){ i := 0 defer func(i int) { fmt.</description>
    </item>
    
  </channel>
</rss>